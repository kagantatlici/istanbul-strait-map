<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Professional nautical chart of Istanbul Strait (Bosphorus) using NOAA Chart Display Service for clean display">
    <meta name="keywords" content="Istanbul Strait, Bosphorus, nautical chart, NOAA charts, maritime navigation, clean display">
    <title>Istanbul Strait Nautical Map</title>
    
    <!-- Preload critical resources for faster loading -->
    <link rel="preconnect" href="https://unpkg.com">
    <link rel="preconnect" href="https://basemaps.cartocdn.com">
    <link rel="preconnect" href="https://gis.charttools.noaa.gov">
    <link rel="preconnect" href="https://tiles.openseamap.org">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
          crossorigin="" />
    
    <style>
        /* ===== MOBILE-FIRST CSS FOUNDATION ===== */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a2e;
            overflow: hidden;
            /* Mobile-first responsive setup */
            display: flex;
            flex-direction: column;
            height: 100vh;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Optimize for mobile touch */
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* ===== MOBILE-ONLY STYLES ===== */
        
        #map {
            height: 100vh;
            width: 100vw;
            background-color: #f0f8ff;
            flex: 1;
            position: relative;
            touch-action: manipulation;
        }
        
        .leaflet-container {
            background-color: #f0f8ff;
            font-family: 'Courier New', monospace;
        }
        
        /* Hide Leaflet attribution for cleaner look */
        .leaflet-control-attribution {
            display: none;
        }
        
        /* Hide Leaflet zoom controls - rely on pinch-to-zoom only */
        .leaflet-control-zoom {
            display: none !important;
        }
        
        /* Header Time Slider - Replaces map title to eliminate overlap */
        .header-time-slider {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 60px; /* Leave space for hamburger menu */
            z-index: 1000;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 50, 100, 0.9));
            color: #ffffff;
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            font-family: 'Courier New', monospace;
            max-width: calc(100vw - 80px);
            display: none; /* Hidden by default, shown when ship simulation is active */
        }
        
        .header-time-slider.active {
            display: block;
        }
        
        .header-time-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            margin-bottom: 4px;
            opacity: 0.8;
        }
        
        .header-time-slider input[type="range"] {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
            margin-bottom: 2px;
        }
        
        .header-time-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            border: 2px solid #0078ff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .header-time-slider input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            border: 2px solid #0078ff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .header-time-info {
            text-align: center;
            font-size: 10px;
            font-weight: bold;
            color: #ffffff;
        }
        
        /* Map title overlay - Only shown when ship simulation is inactive */
        .map-title {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 60px; /* Leave space for hamburger menu */
            z-index: 1000;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 50, 100, 0.9));
            color: #ffffff;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            font-family: 'Courier New', monospace;
            letter-spacing: 0.3px;
            text-align: center;
            max-width: calc(100vw - 80px);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: block;
        }
        
        .map-title.hidden {
            display: none;
        }
        
        /* Loading indicator with nautical theme */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 50, 100, 0.9));
            color: #ffffff;
            padding: 25px 30px;
            border-radius: 12px;
            text-align: center;
            font-size: 18px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 25px rgba(0,0,0,0.6);
            font-family: 'Courier New', monospace;
            letter-spacing: 1px;
        }
        
        .loading.hidden {
            display: none;
        }
        
        /* Filter to reduce arrow clutter on nautical layer */
        .leaflet-layer img {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        
        /* Clean nautical layer styling */
        .nautical-layer {
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }
        
        /* Coordinate display - Hidden for mobile-only interface */
        .coordinate-display {
            display: none;
        }
        
        /* ===== MEETING POINT MARKER STYLING ===== */
        
        .meeting-point-marker {
            width: 24px;
            height: 24px;
            background: radial-gradient(circle, #ff0000, #cc0000);
            border: 3px solid #ffffff;
            border-radius: 50%;
            position: relative;
            animation: meetingPulse 2s infinite;
            box-shadow: 0 2px 8px rgba(255, 0, 0, 0.5);
        }
        
        .meeting-point-marker::before {
            content: '‚ö†';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        
        @keyframes meetingPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); box-shadow: 0 2px 12px rgba(255, 0, 0, 0.8); }
            100% { transform: scale(1); }
        }
        
        /* ===== VERTICAL TIME SLIDER ===== */
        
        .vertical-time-slider {
            position: fixed;
            top: 20%;
            right: 15px;
            height: 60%;
            width: 60px;
            z-index: 1500;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 50, 100, 0.9));
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.6);
            padding: 15px 8px;
            font-family: 'Courier New', monospace;
            color: white;
            display: none;
            flex-direction: column;
            align-items: center;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        
        .vertical-time-slider.active {
            display: flex;
        }
        
        .vertical-time-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 100%;
            position: absolute;
            left: -35px;
            top: 15px;
            bottom: 15px;
            font-size: 9px;
            opacity: 0.9;
            text-align: center;
        }
        
        .vertical-time-labels span {
            transform: rotate(-90deg);
            white-space: nowrap;
        }
        
        .vertical-slider-container {
            height: calc(100% - 40px);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .vertical-time-slider input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 200px; /* This will be the height when rotated */
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            outline: none;
            transform: rotate(-90deg);
            transform-origin: center;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        .vertical-time-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ffffff, #e0e0e0);
            border: 2px solid #0078ff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }
        
        .vertical-time-slider input[type="range"]::-webkit-slider-thumb:active {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        
        .vertical-time-slider input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ffffff, #e0e0e0);
            border: 2px solid #0078ff;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            border: none;
        }
        
        .vertical-time-info {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
        }
        
        /* ===== AIS TOGGLE SWITCH ===== */
        
        .ais-toggle-container {
            position: fixed;
            top: 65px;
            right: 10px;
            z-index: 1500;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 50, 100, 0.9));
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 8px 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            font-family: 'Courier New', monospace;
            color: white;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 120px;
            touch-action: manipulation;
        }
        
        .ais-toggle-label {
            font-size: 10px;
            font-weight: bold;
            color: #ffffff;
            text-align: center;
            flex: 1;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .ais-toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
            flex-shrink: 0;
        }
        
        .ais-toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .ais-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #334155;
            transition: 0.4s;
            border-radius: 28px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .ais-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 3px;
            background: linear-gradient(135deg, #ffffff, #e0e0e0);
            transition: 0.4s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        input:checked + .ais-slider {
            background-color: #2196F3;
            border-color: #1976D2;
        }
        
        input:checked + .ais-slider:before {
            transform: translateX(22px);
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
        }
        
        .ais-status-indicator {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.9);
            background-color: #666;
            transition: all 0.3s ease;
        }
        
        .ais-status-indicator.connecting {
            background-color: #ff9800;
            animation: aisPulse 1s infinite;
        }
        
        .ais-status-indicator.connected {
            background-color: #4caf50;
        }
        
        .ais-status-indicator.error {
            background-color: #f44336;
            animation: aisError 1s infinite;
        }
        
        @keyframes aisPulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        @keyframes aisError {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        /* ===== AIS SHIP MARKER STYLING ===== */
        
        .ais-ship-marker {
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 2px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            transform-origin: center;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
            z-index: 900;
            cursor: pointer;
            touch-action: manipulation;
            transition: all 0.2s ease;
        }
        
        .ais-ship-marker:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(0,0,0,0.6);
            z-index: 901;
        }
        
        .ais-ship-icon {
            font-size: 12px;
            font-weight: bold;
            transition: transform 0.3s ease;
            transform-origin: center;
        }
        
        /* Vessel type specific colors */
        .ais-ship-marker.cargo {
            border: 2px solid #2196F3;
        }
        
        .ais-ship-marker.cargo .ais-ship-icon {
            color: #2196F3;
        }
        
        .ais-ship-marker.tanker {
            border: 2px solid #F44336;
        }
        
        .ais-ship-marker.tanker .ais-ship-icon {
            color: #F44336;
        }
        
        .ais-ship-marker.passenger {
            border: 2px solid #4CAF50;
        }
        
        .ais-ship-marker.passenger .ais-ship-icon {
            color: #4CAF50;
        }
        
        .ais-ship-marker.other {
            border: 2px solid #9E9E9E;
        }
        
        .ais-ship-marker.other .ais-ship-icon {
            color: #9E9E9E;
        }
        
        .ais-ship-marker.fishing {
            border: 2px solid #FF9800;
        }
        
        .ais-ship-marker.fishing .ais-ship-icon {
            color: #FF9800;
        }
        
        .ais-ship-marker.military {
            border: 2px solid #795548;
        }
        
        .ais-ship-marker.military .ais-ship-icon {
            color: #795548;
        }
        
        /* AIS Popup Styling */
        .ais-popup-content {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.4;
            min-width: 200px;
            max-width: 280px;
        }
        
        .ais-popup-content .popup-header {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 50, 100, 0.9));
            color: white;
            padding: 8px 12px;
            margin: -10px -10px 8px -10px;
            border-radius: 3px 3px 0 0;
            text-align: center;
            font-weight: bold;
            font-size: 12px;
        }
        
        .ais-popup-content .popup-info {
            padding: 4px 0;
        }
        
        .ais-popup-content .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            padding: 2px 0;
        }
        
        .ais-popup-content .label {
            font-weight: bold;
            color: #555;
            min-width: 80px;
            flex-shrink: 0;
        }
        
        .ais-popup-content .value {
            color: #333;
            text-align: right;
            flex: 1;
            margin-left: 8px;
            word-break: break-word;
        }
        
        /* Mobile-specific AIS popup adjustments */
        @media (max-width: 768px) {
            .ais-popup-content {
                font-size: 12px;
                min-width: 180px;
                max-width: 240px;
            }
            
            .ais-popup-content .popup-header {
                font-size: 13px;
                padding: 10px;
            }
            
            .ais-popup-content .info-row {
                margin-bottom: 6px;
                padding: 3px 0;
            }
            
            .ais-popup-content .label {
                min-width: 70px;
                font-size: 11px;
            }
            
            .ais-popup-content .value {
                font-size: 11px;
            }
        }
        
        /* AIS vs Simulation Ship Visual Distinction */
        .ais-ship-marker {
            border-style: solid;
            opacity: 0.9;
        }
        
        .ship-marker {
            border-style: dashed; /* Distinguish simulation ships with dashed border */
            opacity: 1.0;
        }
        
        /* Ensure AIS ships don't interfere with simulation */
        .ais-ship-marker {
            z-index: 900; /* Lower than simulation ships */
        }
        
        .ship-marker {
            z-index: 1000; /* Higher than AIS ships */
        }
        
        /* ===== MOBILE HAMBURGER MENU ===== */
        
        .mobile-hamburger-menu {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 2000;
            display: block;
        }
        
        .hamburger-button {
            width: 44px;
            height: 44px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 50, 100, 0.9));
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: white;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            touch-action: manipulation;
        }
        
        .hamburger-button:active {
            transform: scale(0.95);
            background: linear-gradient(135deg, rgba(0, 50, 100, 0.9), rgba(0, 80, 150, 0.9));
        }
        
        .hamburger-dropdown {
            position: absolute;
            top: 50px;
            right: 0;
            min-width: 250px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(0, 50, 100, 0.95));
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.6);
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: white;
            transform: translateY(-10px);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        
        .hamburger-dropdown.show {
            transform: translateY(0);
            opacity: 1;
            visibility: visible;
        }
        
        .hamburger-dropdown::before {
            content: '';
            position: absolute;
            top: -8px;
            right: 15px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid rgba(0, 50, 100, 0.95);
        }
        
        .hamburger-item {
            margin-bottom: 15px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .hamburger-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .hamburger-item-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #ffffff;
            font-size: 13px;
        }
        
        .hamburger-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .hamburger-slider-container {
            margin-top: 8px;
        }
        
        .hamburger-slider {
            width: 100%;
            margin: 5px 0;
        }
        
        .hamburger-slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            opacity: 0.8;
            margin-bottom: 5px;
        }
        
        .hamburger-value-display {
            text-align: center;
            font-size: 11px;
            opacity: 0.9;
            margin-top: 5px;
        }
        
        .mobile-toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }
        
        .mobile-toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .mobile-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.3s;
            border-radius: 20px;
        }
        
        .mobile-toggle-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }
        
        input:checked + .mobile-toggle-slider {
            background-color: #2196F3;
        }
        
        input:checked + .mobile-toggle-slider:before {
            transform: translateX(20px);
        }
        
        /* Range Slider Styling - Mobile Touch Optimized */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            touch-action: manipulation;
        }
        
        input[type="range"]::-webkit-slider-track {
            background: #334155;
            height: 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 28px;
            width: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, #0078ff, #0056b3);
            border: 2px solid #ffffff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            cursor: pointer;
            touch-action: manipulation;
            transition: all 0.2s ease;
        }
        
        input[type="range"]:active::-webkit-slider-thumb {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        
        input[type="range"]::-moz-range-track {
            background: #334155;
            height: 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        input[type="range"]::-moz-range-thumb {
            height: 28px;
            width: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, #0078ff, #0056b3);
            border: 2px solid #ffffff;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            cursor: pointer;
            border: none;
            touch-action: manipulation;
            transition: all 0.2s ease;
        }
        
        /* ===== MOBILE BOTTOM SHEET CONTROL PANEL ===== */
        
        /* Ship Simulation Control Panel - Mobile Only Layout */
        .ship-control-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            max-height: 90vh; /* Increased from 30vh for better content visibility */
            z-index: 1000;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 50, 100, 0.9));
            color: #ffffff;
            padding: 15px;
            border-radius: 16px 16px 0 0;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 -4px 25px rgba(0,0,0,0.6);
            transform: translateY(calc(100% - 60px)); /* Collapsed state - reduced height */
            transition: transform 0.3s ease-out;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            display: none;
        }
        
        .ship-control-panel.expanded {
            transform: translateY(0); /* Expanded state - now uses full 90vh */
        }
        
        .ship-control-panel.collapsed {
            transform: translateY(calc(100% - 60px)); /* Collapsed state - reduced height */
        }
        
        .ship-control-panel.active {
            display: block;
        }
        
        /* ===== BOTTOM SHEET DRAG HANDLE ===== */
        
        .bottom-sheet-drag-handle {
            display: block;
            width: 40px;
            height: 4px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 2px;
            margin: 8px auto 12px auto;
            cursor: pointer;
            touch-action: manipulation;
            transition: background-color 0.2s ease;
        }
        
        .bottom-sheet-drag-handle:active,
        .bottom-sheet-drag-handle.dragging {
            background: rgba(255, 255, 255, 0.8);
        }
        
        /* ===== MOBILE PANEL HEADER ===== */
        
        .mobile-panel-header {
            display: block;
            text-align: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 15px;
            position: sticky;
            top: 0;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 50, 100, 0.9));
            z-index: 1;
        }
        
        /* ===== MOBILE TABBED INTERFACE ===== */
        
        .mobile-tab-navigation {
            display: flex;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            margin: 0 10px 15px 10px;
            overflow: hidden;
        }
        
        .mobile-tab-button {
            flex: 1;
            padding: 12px 8px;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-family: 'Courier New', monospace;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            touch-action: manipulation;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .mobile-tab-button:last-child {
            border-right: none;
        }
        
        .mobile-tab-button.active {
            background: rgba(255, 255, 255, 0.2);
            color: #ffffff;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .mobile-tab-button:active {
            transform: scale(0.98);
        }
        
        /* ===== MOBILE TAB CONTENT PANELS ===== */
        
        .mobile-tab-content {
            display: block;
            overflow-y: visible; /* Remove scrolling - use full 90vh space */
            max-height: calc(90vh - 120px); /* Account for header and tab navigation */
        }
        
        .mobile-tab-panel {
            display: none;
            padding: 0 10px;
        }
        
        .mobile-tab-panel.active {
            display: block;
        }
        
        /* Hide desktop ship sections on mobile */
        .ship-section {
            display: none;
        }
        
        /* Hide desktop time control on mobile */
        .time-control {
            display: none;
        }
        
        .ship-control-panel h4 {
            display: none;
        }
        
        .control-group {
            margin-bottom: 10px; /* Reduced from 12px for better space utilization */
        }
        
        .control-group label {
            display: block;
            margin-bottom: 6px; /* Reduced margin */
            font-weight: bold;
            font-size: 11px; /* Slightly smaller for better fit */
        }
        
        .control-group input[type="number"] {
            width: 100%;
            padding: 6px; /* Reduced padding */
            font-size: 13px; /* Slightly smaller */
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-family: 'Courier New', monospace;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 11px;
        }
        
        .control-group input[type="number"] {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 16px; /* Prevent zoom on iOS */
            min-height: 44px;
            box-sizing: border-box;
            touch-action: manipulation;
        }
        
        .control-group input[type="number"]:focus {
            outline: none;
            border-color: #0078ff;
            background: rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 8px rgba(0, 120, 255, 0.3);
        }
        
        .direction-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
        }
        
        .direction-option {
            flex: 1;
            padding: 12px 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            touch-action: manipulation;
            user-select: none;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        
        .direction-option:active {
            transform: scale(0.98);
            background: rgba(255, 255, 255, 0.3);
        }
        
        .direction-option:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #0078ff;
        }
        
        .direction-option.selected {
            background: #0078ff !important; /* Full background color change */
            border-color: #0078ff !important;
            color: #ffffff !important;
            font-weight: bold;
            box-shadow: 0 0 12px rgba(0, 120, 255, 0.4);
        }
        
        .time-control {
            margin-top: 15px;
        }
        
        .time-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            margin-bottom: 5px;
            opacity: 0.8;
        }
        
        .ship-info {
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 10px;
            line-height: 1.4;
        }
        
        .ship-info .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }
        
        /* Ship Enable Toggle - Mobile FAB Style */
        .ship-toggle {
            position: fixed;
            bottom: 80px; /* Positioned above floating time slider */
            right: 20px; /* Bottom-right corner */
            z-index: 1500;
            width: 56px;
            height: 56px;
            border-radius: 50%; /* Circular FAB */
            background: linear-gradient(135deg, #1565C0, #0D47A1);
            color: #ffffff;
            border: none;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
            font-size: 20px;
            font-family: 'Courier New', monospace;
        }
        
        .ship-toggle:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .ship-toggle.active {
            background: linear-gradient(135deg, #0078ff, #0056b3);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 4px 16px rgba(0,0,0,0.3); }
            50% { box-shadow: 0 4px 20px rgba(0, 120, 255, 0.6); }
            100% { box-shadow: 0 4px 16px rgba(0,0,0,0.3); }
        }
        
        /* ===== FLOATING TIME SLIDER ===== */
        
        .floating-time-slider {
            position: fixed;
            bottom: 30px;
            left: 10%;
            right: 10%;
            height: 50px;
            z-index: 1400;
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            padding: 8px 16px;
            font-family: 'Courier New', monospace;
            color: white;
            font-size: 11px;
            transform: translateY(100px);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease-out;
            display: flex;
            flex-direction: column;
            justify-content: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }
        
        .floating-time-slider.active {
            transform: translateY(0);
            opacity: 1;
            visibility: visible;
        }
        
        .floating-time-slider.auto-hide {
            animation: fadeOutSlider 3s forwards;
        }
        
        @keyframes fadeOutSlider {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; visibility: hidden; }
        }
        
        .floating-time-labels {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2px;
            opacity: 0.8;
            font-size: 9px;
        }
        
        .floating-time-slider input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            margin: 0;
        }
        
        .floating-time-slider input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #0078ff;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .floating-time-slider input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #0078ff;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .floating-time-info {
            text-align: center;
            margin-top: 2px;
            font-size: 10px;
            opacity: 0.9;
        }
        
        /* Ship marker styling - Mobile Touch Optimized */
        .ship-marker-custom {
            background: transparent !important;
            border: none !important;
        }
        
        .ship-marker {
            width: 44px;
            height: 44px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            transform-origin: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 1000;
            position: relative;
            transition: all 0.2s ease;
            touch-action: manipulation;
        }
        
        .ship-marker:active {
            transform: scale(1.1);
            box-shadow: 0 4px 16px rgba(0,0,0,0.5);
        }
        
        .ship-marker.own-ship {
            border: 2px solid #2196F3;
        }
        
        .ship-marker.other-ship {
            border: 2px solid #FF9800;
        }
        
        .ship-marker.selected {
            box-shadow: 0 0 15px rgba(0, 120, 255, 0.8);
        }
        
        .ship-marker.warning {
            animation: warningPulse 1s infinite;
            border-color: #FF5252 !important;
        }
        
        @keyframes warningPulse {
            0% { box-shadow: 0 0 5px rgba(255, 82, 82, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 82, 82, 1); }
            100% { box-shadow: 0 0 5px rgba(255, 82, 82, 0.5); }
        }
        
        .ship-marker.own-ship::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 16px solid #2196F3;
            transform: translate(-50%, -50%);
        }
        
        .ship-marker.other-ship::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 16px solid #FF9800;
            transform: translate(-50%, -50%);
        }
        
        /* ===== MOBILE TYPOGRAPHY SYSTEM ===== */
        
        /* Base Typography - Mobile Optimized */
        .nautical-text {
            font-family: 'Courier New', 'Courier', monospace;
            letter-spacing: 0.4px;
            font-weight: normal;
            line-height: 1.5;
            font-size: 13px;
        }
        
        .nautical-heading {
            font-family: 'Courier New', 'Courier', monospace;
            font-weight: bold;
            letter-spacing: 0.6px;
            line-height: 1.2;
            font-size: 16px;
        }
        
        .nautical-text.small {
            font-size: 11px;
        }
        
        .nautical-text.large {
            font-size: 16px;
        }
            .nautical-text {
                font-size: 14px;
                letter-spacing: 0.5px;
                line-height: 1.4;
            }
            
            .nautical-heading {
                font-size: 18px;
                letter-spacing: 0.7px;
            }
            
            .nautical-text.small {
                font-size: 12px;
            }
            
            .nautical-text.large {
                font-size: 17px;
            }
        
        /* ===== TOUCH-OPTIMIZED SPACING SYSTEM ===== */
        
        /* Base spacing for mobile touch */
        .touch-spacing {
            margin: 8px;
            padding: 8px;
        }
        
        .touch-spacing-large {
            margin: 12px;
            padding: 12px;
        }
        
        .touch-spacing-small {
            margin: 4px;
            padding: 4px;
        }
        
        /* Control group spacing optimized for mobile */
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            font-size: 12px;
            line-height: 1.4;
        }
        
        /* Enhanced button spacing for touch */
        .direction-selector {
            display: flex;
            gap: 12px;
            margin-bottom: 15px;
        }
        
        /* Mobile panel spacing - optimized for 90vh */
        .ship-section {
            margin-bottom: 15px; /* Reduced from 20px */
            padding: 12px; /* Reduced from 15px */
        }
        
        /* Mobile tab panel optimizations */
        .mobile-tab-panel {
            display: none;
            padding: 0 8px; /* Reduced from 10px */
        }
        
        .mobile-time-control {
            margin-top: 12px; /* Reduced spacing */
            padding: 12px 8px; /* Optimized padding */
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* Time control spacing */
        .time-control {
            margin-top: 20px;
        }
        
        .time-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            margin-bottom: 8px;
            opacity: 0.8;
            line-height: 1.4;
        }
        
        /* Ship info spacing */
        .ship-info {
            margin-top: 15px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 11px;
            line-height: 1.5;
        }
        
        .ship-info .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            padding: 4px 0;
        }
        
        /* ===== SINGLE MEETING POINT MARKER STYLING ===== */
        
        .single-meeting-marker {
            width: 20px;
            height: 20px;
            background: #FF5252;
            border: 4px solid white;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(255, 82, 82, 0.6);
            z-index: 999;
            position: relative;
            animation: meetingPulse 2s infinite;
        }
        
        .single-meeting-marker::before {
            content: '';
            position: absolute;
            top: -8px;
            left: -8px;
            right: -8px;
            bottom: -8px;
            border: 2px solid rgba(255, 82, 82, 0.3);
            border-radius: 50%;
            animation: meetingRipple 2s infinite;
        }
        
        @keyframes meetingPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        @keyframes meetingRipple {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        Loading Istanbul Strait Chart...
    </div>
    
    <!-- Header Time Slider Component - Replaces map title when ship simulation is active -->
    <div class="header-time-slider" id="headerTimeSlider">
        <div class="header-time-labels">
            <span>Now</span>
            <span>+60 min</span>
        </div>
        <input type="range" id="headerTimeControl" min="0" max="60" value="0" step="1">
        <div class="header-time-info" id="headerTimeInfo">Now</div>
    </div>

    <div class="map-title" id="mapTitle">
        ƒ∞STANBUL BOƒûAZ HARƒ∞TASI
    </div>
    
    <div class="coordinate-display" id="coordinates">
        Lat: --.----- Lng: ---.-----
    </div>
    
    <!-- Mobile Hamburger Menu -->
    <div class="mobile-hamburger-menu">
        <div class="hamburger-button" onclick="toggleHamburgerMenu()">
            ‚ò∞
        </div>
        <div class="hamburger-dropdown" id="hamburgerDropdown">
            <div class="hamburger-item">
                <div class="hamburger-item-title">üåä Layer Controls</div>
                <div class="hamburger-slider-container">
                    <div class="hamburger-slider-label">
                        <span>OpenSeaMap Opacity:</span>
                    </div>
                    <input type="range" id="mobileOpacitySlider" class="hamburger-slider" min="0" max="100" value="30">
                    <div class="hamburger-value-display">
                        Value: <span id="mobileOpacityValue">30</span>%
                    </div>
                </div>
            </div>
            
            <div class="hamburger-item">
                <div class="hamburger-toggle">
                    <span class="hamburger-item-title">üåô Dark Mode:</span>
                    <label class="mobile-toggle-switch">
                        <input type="checkbox" id="mobileDarkModeToggle">
                        <span class="mobile-toggle-slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="hamburger-item">
                <div class="hamburger-toggle">
                    <span class="hamburger-item-title">üìç Coordinates:</span>
                    <label class="mobile-toggle-switch">
                        <input type="checkbox" id="mobileCoordinatesToggle">
                        <span class="mobile-toggle-slider"></span>
                    </label>
                </div>
                <div id="mobileCoordinatesDisplay" style="font-size: 11px; opacity: 0.8; margin-top: 5px; display: none;">
                    Lat: --.----- Lng: ---.-----
                </div>
            </div>
            
            <div class="hamburger-item">
                <div class="hamburger-item-title">üö¢ AIS Gemi Takibi</div>
                <div class="hamburger-toggle">
                    <span style="font-size: 11px; opacity: 0.9;">AIS Tracking:</span>
                    <label class="mobile-toggle-switch">
                        <input type="checkbox" id="mobileAISToggle">
                        <span class="mobile-toggle-slider"></span>
                    </label>
                </div>
                
                <div id="aisStatusDisplay" style="font-size: 10px; opacity: 0.8; margin: 5px 0; text-align: center; color: #666;">
                    AIS Baƒülantƒ±sƒ± kapalƒ±
                </div>
                
                <div class="ship-filter-section" id="shipFilterSection" style="margin-top: 8px; display: none;">
                    <div style="font-size: 11px; font-weight: bold; margin-bottom: 6px; opacity: 0.9;">Gemi Tipleri:</div>
                    
                    <label class="filter-checkbox" style="display: flex; align-items: center; margin-bottom: 4px; font-size: 10px;">
                        <input type="checkbox" id="cargoFilter" checked style="margin-right: 6px;">
                        <span style="color: #2196F3; margin-right: 4px;">‚ñ†</span>
                        <span>Kargo Gemileri</span>
                    </label>
                    
                    <label class="filter-checkbox" style="display: flex; align-items: center; margin-bottom: 4px; font-size: 10px;">
                        <input type="checkbox" id="tankerFilter" checked style="margin-right: 6px;">
                        <span style="color: #F44336; margin-right: 4px;">‚ñ†</span>
                        <span>Tankerler</span>
                    </label>
                    
                    <label class="filter-checkbox" style="display: flex; align-items: center; margin-bottom: 4px; font-size: 10px;">
                        <input type="checkbox" id="passengerFilter" checked style="margin-right: 6px;">
                        <span style="color: #4CAF50; margin-right: 4px;">‚ñ†</span>
                        <span>Yolcu Gemileri</span>
                    </label>
                    
                    <label class="filter-checkbox" style="display: flex; align-items: center; margin-bottom: 4px; font-size: 10px;">
                        <input type="checkbox" id="otherFilter" checked style="margin-right: 6px;">
                        <span style="color: #9E9E9E; margin-right: 4px;">‚ñ†</span>
                        <span>Diƒüer</span>
                    </label>
                </div>
            </div>
        </div>
    </div>
    
    <!-- AIS Toggle Switch -->
    <div class="ais-toggle-container" id="aisToggleContainer">
        <div class="ais-toggle-label">AIS</div>
        <label class="ais-toggle-switch">
            <input type="checkbox" id="aisToggleInput">
            <span class="ais-slider"></span>
        </label>
        <div class="ais-status-indicator" id="aisStatusIndicator"></div>
    </div>
    
    <div class="ship-toggle" id="shipToggle" onclick="toggleShipSimulation()" title="Ship Simulation">
        üö¢
    </div>
    
    <!-- Floating Time Slider Component -->
    <div class="floating-time-slider" id="floatingTimeSlider">
        <div class="floating-time-labels">
            <span>Now</span>
            <span>+60 min</span>
        </div>
        <input type="range" id="floatingTimeControl" min="0" max="60" value="0" step="1">
        <div class="floating-time-info" id="floatingTimeInfo">Now</div>
    </div>
    
    <!-- Vertical Time Slider -->
    <div class="vertical-time-slider" id="verticalTimeSlider">
        <div class="vertical-time-labels">
            <span>+60</span>
            <span>+30</span>
            <span>Now</span>
        </div>
        <div class="vertical-slider-container">
            <input type="range" id="verticalTimeControl" min="0" max="60" value="0" step="1">
        </div>
        <div class="vertical-time-info" id="verticalTimeInfo">Now</div>
    </div>
    
    <div class="ship-control-panel" id="shipControlPanel">
        <!-- Mobile Drag Handle -->
        <div class="bottom-sheet-drag-handle" id="bottomSheetDragHandle"></div>
        
        <!-- Mobile Panel Header -->
        <div class="mobile-panel-header">
            <h4>‚öì Dual Ship Route Simulation</h4>
        </div>
        
        <!-- Desktop Header (hidden on mobile) -->
        <h4>‚öì Dual Ship Route Simulation</h4>
        
        <!-- Mobile Tab Navigation -->
        <div class="mobile-tab-navigation">
            <button class="mobile-tab-button active" onclick="switchMobileTab('ownShip')">üö¢ Own Ship</button>
            <button class="mobile-tab-button" onclick="switchMobileTab('otherShip')">üö¢ Other Ship</button>
        </div>
        
        <!-- Mobile Tab Content -->
        <div class="mobile-tab-content">
            <!-- Own Ship Tab Panel -->
            <div class="mobile-tab-panel active" id="ownShipPanel">
                <div style="padding: 10px; border: 1px solid rgba(33, 150, 243, 0.5); border-radius: 5px; background: rgba(33, 150, 243, 0.1); margin-bottom: 15px;">
                    <h5 style="margin: 0 0 12px 0; color: #2196F3; font-size: 13px; text-align: center;">üö¢ OWN SHIP (Blue)</h5>
                    
                    <div class="control-group" style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: bold; font-size: 12px;">Direction:</label>
                        <div class="direction-selector">
                            <div class="direction-option selected" id="mobileOwnNorthbound" onclick="selectShipDirection('own', 'northbound')">
                                ‚¨ÜÔ∏è Northbound<br><small>(South ‚Üí North)</small>
                            </div>
                            <div class="direction-option" id="mobileOwnSouthbound" onclick="selectShipDirection('own', 'southbound')">
                                ‚¨áÔ∏è Southbound<br><small>(North ‚Üí South)</small>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label for="mobileOwnShipSpeed" style="display: block; margin-bottom: 8px; font-weight: bold; font-size: 12px;">Speed (knots):</label>
                        <input type="number" id="mobileOwnShipSpeed" min="1" max="15" value="8" step="0.5" style="width: 100%; padding: 8px; font-size: 14px; border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.3); background: rgba(255, 255, 255, 0.1); color: white; font-family: 'Courier New', monospace;">
                    </div>
                </div>
            </div>
            
            <!-- Other Ship Tab Panel -->
            <div class="mobile-tab-panel" id="otherShipPanel">
                <div style="padding: 10px; border: 1px solid rgba(255, 152, 0, 0.5); border-radius: 5px; background: rgba(255, 152, 0, 0.1); margin-bottom: 15px;">
                    <h5 style="margin: 0 0 12px 0; color: #FF9800; font-size: 13px; text-align: center;">üö¢ OTHER SHIP (Orange)</h5>
                    
                    <div class="control-group" style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: bold; font-size: 12px;">Direction:</label>
                        <div class="direction-selector">
                            <div class="direction-option selected" id="mobileOtherNorthbound" onclick="selectShipDirection('other', 'northbound')">
                                ‚¨ÜÔ∏è Northbound<br><small>(South ‚Üí North)</small>
                            </div>
                            <div class="direction-option" id="mobileOtherSouthbound" onclick="selectShipDirection('other', 'southbound')">
                                ‚¨áÔ∏è Southbound<br><small>(North ‚Üí South)</small>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label for="mobileOtherShipSpeed" style="display: block; margin-bottom: 8px; font-weight: bold; font-size: 12px;">Speed (knots):</label>
                        <input type="number" id="mobileOtherShipSpeed" min="1" max="15" value="10" step="0.5" style="width: 100%; padding: 8px; font-size: 14px; border-radius: 6px; border: 1px solid rgba(255, 255, 255, 0.3); background: rgba(255, 255, 255, 0.1); color: white; font-family: 'Courier New', monospace;">
                    </div>
                </div>
            </div>
            
            <!-- Unified Time Control for Mobile -->
            <div class="mobile-time-control" style="margin-top: 15px; padding: 15px 10px; border-top: 1px solid rgba(255, 255, 255, 0.2);">
                <!-- Meeting Warning Section -->
                <div id="mobileMeetingWarning" class="meeting-warning" style="background: rgba(255, 82, 82, 0.2); border: 1px solid #FF5252; border-radius: 5px; padding: 8px; margin-bottom: 12px; text-align: center; font-size: 11px; color: #FF5252; font-weight: bold; display: none;">
                    ‚ö†Ô∏è WARNING: VESSELS MEETING ‚ö†Ô∏è
                    <div id="mobileMeetingTime" style="font-size: 10px; margin-top: 3px;">Calculating...</div>
                </div>
                
                <!-- Time Control -->
                <div class="time-labels" style="display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 8px; opacity: 0.8;">
                    <span>Now</span>
                    <span>+60 min</span>
                </div>
                <input type="range" id="mobileTimeSlider" min="0" max="60" value="0" step="1" style="width: 100%; height: 8px;">
                
                <!-- Essential Meeting Info -->
                <div class="ship-info" style="font-size: 11px; line-height: 1.4; margin-top: 12px; padding-top: 8px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                    <div class="info-item" style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                        <span>Simulation Time:</span>
                        <span id="mobilePositionTime">Now</span>
                    </div>
                    <div class="info-item" style="display: flex; justify-content: space-between;">
                        <span>Next Meeting:</span>
                        <span id="mobileNextMeeting">Calculating...</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Own Ship Controls -->
        <div class="ship-section" style="margin-bottom: 15px; padding: 10px; border: 1px solid rgba(33, 150, 243, 0.5); border-radius: 5px; background: rgba(33, 150, 243, 0.1);">
            <h5 style="margin: 0 0 8px 0; color: #2196F3; font-size: 11px;">üö¢ OWN SHIP (Blue)</h5>
            
            <div class="control-group">
                <label>Direction:</label>
                <div class="direction-selector">
                    <div class="direction-option selected" id="ownNorthbound" onclick="selectShipDirection('own', 'northbound')">
                        ‚¨ÜÔ∏è Northbound<br><small>(South ‚Üí North)</small>
                    </div>
                    <div class="direction-option" id="ownSouthbound" onclick="selectShipDirection('own', 'southbound')">
                        ‚¨áÔ∏è Southbound<br><small>(North ‚Üí South)</small>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="ownShipSpeed">Speed (knots):</label>
                <input type="number" id="ownShipSpeed" min="1" max="15" value="8" step="0.5">
            </div>
        </div>
        
        <!-- Other Ship Controls -->
        <div class="ship-section" style="margin-bottom: 15px; padding: 10px; border: 1px solid rgba(255, 152, 0, 0.5); border-radius: 5px; background: rgba(255, 152, 0, 0.1);">
            <h5 style="margin: 0 0 8px 0; color: #FF9800; font-size: 11px;">üö¢ OTHER SHIP (Orange)</h5>
            
            <div class="control-group">
                <label>Direction:</label>
                <div class="direction-selector">
                    <div class="direction-option selected" id="otherNorthbound" onclick="selectShipDirection('other', 'northbound')">
                        ‚¨ÜÔ∏è Northbound<br><small>(South ‚Üí North)</small>
                    </div>
                    <div class="direction-option" id="otherSouthbound" onclick="selectShipDirection('other', 'southbound')">
                        ‚¨áÔ∏è Southbound<br><small>(North ‚Üí South)</small>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <label for="otherShipSpeed">Speed (knots):</label>
                <input type="number" id="otherShipSpeed" min="1" max="15" value="10" step="0.5">
            </div>
        </div>
        
        <!-- Unified Time Control -->
        <div class="time-control">
            <div class="time-labels">
                <span>Now</span>
                <span>+60 min</span>
            </div>
            <input type="range" id="timeSlider" min="0" max="60" value="0" step="1">
        </div>
        
        <!-- Meeting Point Warning -->
        <div id="meetingWarning" class="meeting-warning" style="display: none; background: rgba(255, 82, 82, 0.2); border: 1px solid #FF5252; border-radius: 5px; padding: 8px; margin-top: 10px; text-align: center; font-size: 11px; color: #FF5252; font-weight: bold;">
            ‚ö†Ô∏è WARNING: VESSELS MEETING ‚ö†Ô∏è
            <div id="meetingTime" style="font-size: 10px; margin-top: 3px;"></div>
        </div>
        
        <!-- Ship Information -->
        <div class="ship-info">
            <div class="info-item">
                <span>Simulation Time:</span>
                <span id="positionTime">Now</span>
            </div>
            <div class="info-item">
                <span>Next Meeting:</span>
                <span id="nextMeeting">Calculating...</span>
            </div>
        </div>
    </div>
    
    <div id="map"></div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" 
            crossorigin=""></script>
    
    <script>
        // Istanbul Strait coordinates and boundaries
        const ISTANBUL_STRAIT_CENTER = [41.035, 29.059];
        const INITIAL_ZOOM = 12;
        const MIN_ZOOM = 10;
        const MAX_ZOOM = 15;
        
        // Ship simulation variables
        let shipSimulationActive = false;
        let shipRoute = null;
        let routeWaypoints = [];
        let routeDistances = [];
        let totalRouteDistance = 0;
        let currentTime = 0; // minutes from start
        let animationFrame = null;
        let currentRouteWaypoints = []; // Active route based on direction
        let singleMeetingMarker = null; // Single marker for nearest meeting point
        let warningActive = false; // Flag for collision warning state
        let dynamicMeetingMarker = null; // Dynamic red meeting point marker
        let verticalSliderActive = false; // Flag for vertical slider state
        
        // ===== AIS CONFIGURATION AND MANAGEMENT SYSTEM =====
        
        // AIS Configuration
        const AIS_CONFIG = {
            WS_URL: 'wss://stream.aisstream.io/v0/stream',
            API_KEY: 'd9f7e48524cd9b6f07f782a19968d1d01fda4274',
            BOUNDING_BOX: [40.85, 28.75, 41.25, 29.30], // Istanbul Strait boundaries
            RECONNECT_INTERVAL: 5000,
            MAX_RECONNECT_ATTEMPTS: 10,
            MAX_SHIPS: 50,
            CLEANUP_INTERVAL: 60000 // 60 seconds
        };
        
        // AIS Ship Data Structure
        class AISShipData {
            constructor(mmsi, shipName, latitude, longitude, speed, heading, vesselType, timestamp) {
                this.mmsi = mmsi;
                this.shipName = shipName || 'Unknown';
                this.latitude = latitude;
                this.longitude = longitude;
                this.speed = speed || 0;
                this.heading = heading || 0;
                this.vesselType = vesselType || 'unknown';
                this.timestamp = timestamp;
                this.lastUpdate = Date.now();
            }
        }
        
        // AIS Connection Manager
        class AISConnectionManager {
            constructor() {
                this.websocket = null;
                this.connectionState = 'disconnected'; // disconnected, connecting, connected, error
                this.reconnectAttempts = 0;
                this.isEnabled = false;
                this.uiManager = null;
                this.dataManager = null;
                this.onMessageCallback = null;
            }
            
            setUIManager(uiManager) {
                this.uiManager = uiManager;
            }
            
            setDataManager(dataManager) {
                this.dataManager = dataManager;
            }
            
            setMessageCallback(callback) {
                this.onMessageCallback = callback;
            }
            
            connect() {
                if (this.connectionState === 'connected' || this.connectionState === 'connecting') {
                    return;
                }
                
                this.connectionState = 'connecting';
                this.updateUI('connecting', 'AIS Baƒülantƒ±sƒ± kuruluyor...');
                
                // Check if running in browser environment
                if (typeof window !== 'undefined' && window.location.protocol === 'https:') {
                    this.handleConnectionError('CORS_BLOCKED', new Error('AISStream.io blocks browser connections for security reasons'));
                    return;
                }
                
                try {
                    this.websocket = new WebSocket(AIS_CONFIG.WS_URL);
                    this.setupEventHandlers();
                } catch (error) {
                    this.handleConnectionError('WEBSOCKET_ERROR', error);
                }
            }
            
            disconnect() {
                this.isEnabled = false;
                this.connectionState = 'disconnected';
                
                if (this.websocket) {
                    this.websocket.close();
                    this.websocket = null;
                }
                
                this.updateUI('disconnected', 'AIS Baƒülantƒ±sƒ± kapalƒ±');
                
                // Clear all AIS ships
                if (this.dataManager) {
                    this.dataManager.clearAllShips();
                }
            }
            
            setupEventHandlers() {
                this.websocket.onopen = () => {
                    this.connectionState = 'connected';
                    this.reconnectAttempts = 0;
                    this.sendSubscription();
                    this.updateUI('connected', `AIS Aktif`);
                    console.log('AIS WebSocket connected successfully');
                };
                
                this.websocket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (this.onMessageCallback) {
                            this.onMessageCallback(data);
                        }
                    } catch (error) {
                        console.error('AIS message parse error:', error);
                    }
                };
                
                this.websocket.onerror = (error) => {
                    console.error('AIS WebSocket error:', error);
                    this.handleConnectionError('WEBSOCKET_ERROR', error);
                };
                
                this.websocket.onclose = (event) => {
                    console.log('AIS WebSocket closed:', event.code, event.reason);
                    this.connectionState = 'disconnected';
                    
                    if (this.isEnabled && this.reconnectAttempts < AIS_CONFIG.MAX_RECONNECT_ATTEMPTS) {
                        this.scheduleReconnect();
                    } else {
                        this.updateUI('disconnected', 'AIS Baƒülantƒ±sƒ± kapalƒ±');
                    }
                };
            }
            
            sendSubscription() {
                const subscriptionMessage = {
                    APIKey: AIS_CONFIG.API_KEY,
                    BoundingBoxes: [AIS_CONFIG.BOUNDING_BOX],
                    FiltersShipAndCargo: true,
                    FilterMessageTypes: ["PositionReport"]
                };
                
                this.websocket.send(JSON.stringify(subscriptionMessage));
                console.log('AIS subscription sent:', subscriptionMessage);
            }
            
            scheduleReconnect() {
                this.reconnectAttempts++;
                const delay = Math.min(AIS_CONFIG.RECONNECT_INTERVAL * this.reconnectAttempts, 30000);
                
                this.updateUI('connecting', `Tekrar baƒülanƒ±yor... (${this.reconnectAttempts}/${AIS_CONFIG.MAX_RECONNECT_ATTEMPTS})`);
                
                setTimeout(() => {
                    if (this.isEnabled) {
                        this.connect();
                    }
                }, delay);
            }
            
            handleConnectionError(errorType, error) {
                this.connectionState = 'error';
                
                const errorMessages = {
                    'WEBSOCKET_ERROR': 'WebSocket baƒülantƒ± hatasƒ±',
                    'CORS_BLOCKED': 'AIS Demo Modu (Ger√ßek veriler i√ßin backend gerekli)',
                    'INVALID_API_KEY': 'API key ge√ßersiz',
                    'RATE_LIMIT': 'Rate limit a≈üƒ±ldƒ±',
                    'NETWORK_ERROR': 'Aƒü baƒülantƒ± sorunu',
                    'PARSE_ERROR': 'Veri ayrƒ±≈ütƒ±rma hatasƒ±'
                };
                
                const message = errorMessages[errorType] || 'Bilinmeyen hata';
                
                // For CORS issues, show demo mode and start simulation
                if (errorType === 'CORS_BLOCKED') {
                    this.updateUI('demo', message);
                    this.startDemoMode();
                } else {
                    this.updateUI('error', message);
                }
                
                console.error(`AIS Error (${errorType}):`, error);
            }
            
            updateUI(status, message) {
                if (this.uiManager) {
                    this.uiManager.updateConnectionStatus(status, message);
                }
            }
            
            enable() {
                this.isEnabled = true;
                this.connect();
            }
            
            disable() {
                this.isEnabled = false;
                this.disconnect();
            }
            
            getConnectionState() {
                return this.connectionState;
            }
            
            startDemoMode() {
                // Start demo mode with simulated AIS data
                this.updateUI('demo', 'AIS Demo Modu - √ñrnek veriler g√∂steriliyor');
                
                // Create demo ships with realistic data for Istanbul Strait
                const demoShips = [
                    {
                        mmsi: '271002099',
                        shipName: 'DEMO CARGO VESSEL',
                        latitude: 41.0335,
                        longitude: 29.0095,
                        heading: 45,
                        speed: 8.5,
                        vesselType: 'Cargo',
                        lastUpdate: Date.now()
                    },
                    {
                        mmsi: '271002100',
                        shipName: 'DEMO TANKER',
                        latitude: 41.0285,
                        longitude: 29.0145,
                        heading: 225,
                        speed: 6.2,
                        vesselType: 'Tanker',
                        lastUpdate: Date.now()
                    },
                    {
                        mmsi: '271002101',
                        shipName: 'DEMO FERRY',
                        latitude: 41.0385,
                        longitude: 29.0065,
                        heading: 135,
                        speed: 12.0,
                        vesselType: 'Passenger',
                        lastUpdate: Date.now()
                    }
                ];
                
                // Add demo ships to map
                if (this.dataManager) {
                    demoShips.forEach(ship => {
                        this.dataManager.addOrUpdateShip(ship);
                    });
                }
                
                console.log('AIS Demo mode activated with simulated ships');
            }
        }
        
        // AIS Data Manager
        class AISDataManager {
            constructor() {
                this.shipData = new Map(); // MMSI -> AISShipData
                this.shipMarkers = new Map(); // MMSI -> Leaflet Marker
                this.aisLayerGroup = L.layerGroup();
                this.maxShips = AIS_CONFIG.MAX_SHIPS;
                this.cleanupInterval = null;
                this.markerManager = null;
                this.filters = {
                    cargo: true,
                    tanker: true,
                    passenger: true,
                    other: true
                };
            }
            
            setMarkerManager(markerManager) {
                this.markerManager = markerManager;
            }
            
            addToMap(map) {
                this.aisLayerGroup.addTo(map);
            }
            
            removeFromMap() {
                this.aisLayerGroup.remove();
            }
            
            addOrUpdateShip(shipData) {
                const existing = this.shipData.get(shipData.mmsi);
                
                // Update ship data
                this.shipData.set(shipData.mmsi, shipData);
                
                // Check if ship type is filtered
                if (!this.isShipTypeVisible(shipData.vesselType)) {
                    return;
                }
                
                // Update or create marker
                this.updateShipMarker(shipData);
                
                // Enforce ship limits
                this.enforceShipLimit();
            }
            
            updateShipMarker(shipData) {
                if (!this.markerManager) return;
                
                let marker = this.shipMarkers.get(shipData.mmsi);
                
                if (marker) {
                    // Update existing marker
                    marker.setLatLng([shipData.latitude, shipData.longitude]);
                    
                    // Update marker rotation
                    const iconElement = marker.getElement();
                    if (iconElement) {
                        const shipIcon = iconElement.querySelector('.ais-ship-icon');
                        if (shipIcon) {
                            shipIcon.style.transform = `rotate(${shipData.heading || 0}deg)`;
                        }
                    }
                    
                    // Update popup content
                    const popupContent = this.markerManager.createPopupContent(shipData);
                    marker.setPopupContent(popupContent);
                } else {
                    // Create new marker
                    marker = this.markerManager.createShipMarker(shipData);
                    this.shipMarkers.set(shipData.mmsi, marker);
                    this.aisLayerGroup.addLayer(marker);
                }
            }
            
            removeShip(mmsi) {
                const marker = this.shipMarkers.get(mmsi);
                if (marker) {
                    this.aisLayerGroup.removeLayer(marker);
                    this.shipMarkers.delete(mmsi);
                }
                this.shipData.delete(mmsi);
            }
            
            clearAllShips() {
                this.aisLayerGroup.clearLayers();
                this.shipMarkers.clear();
                this.shipData.clear();
            }
            
            startCleanupProcess() {
                this.cleanupInterval = setInterval(() => {
                    this.cleanupOldShips();
                }, 30000); // Every 30 seconds
            }
            
            stopCleanupProcess() {
                if (this.cleanupInterval) {
                    clearInterval(this.cleanupInterval);
                    this.cleanupInterval = null;
                }
            }
            
            cleanupOldShips() {
                const now = Date.now();
                const cleanupThreshold = AIS_CONFIG.CLEANUP_INTERVAL;
                let removedCount = 0;
                
                for (const [mmsi, ship] of this.shipData.entries()) {
                    if (now - ship.lastUpdate > cleanupThreshold) {
                        this.removeShip(mmsi);
                        removedCount++;
                    }
                }
                
                if (removedCount > 0) {
                    console.log(`AIS: Cleaned up ${removedCount} inactive ships`);
                }
            }
            
            enforceShipLimit() {
                const shipCount = this.shipData.size;
                if (shipCount > this.maxShips) {
                    // Remove oldest ships
                    const sortedShips = Array.from(this.shipData.entries())
                        .sort((a, b) => a[1].lastUpdate - b[1].lastUpdate);
                    
                    const toRemove = shipCount - this.maxShips;
                    for (let i = 0; i < toRemove; i++) {
                        this.removeShip(sortedShips[i][0]);
                    }
                }
            }
            
            updateFilters(newFilters) {
                this.filters = { ...this.filters, ...newFilters };
                this.applyFilters();
            }
            
            applyFilters() {
                for (const [mmsi, shipData] of this.shipData.entries()) {
                    const marker = this.shipMarkers.get(mmsi);
                    if (marker) {
                        if (this.isShipTypeVisible(shipData.vesselType)) {
                            if (!this.aisLayerGroup.hasLayer(marker)) {
                                this.aisLayerGroup.addLayer(marker);
                            }
                        } else {
                            this.aisLayerGroup.removeLayer(marker);
                        }
                    }
                }
            }
            
            isShipTypeVisible(vesselType) {
                const type = this.categorizeVesselType(vesselType);
                return this.filters[type];
            }
            
            categorizeVesselType(vesselType) {
                if (!vesselType) return 'other';
                
                const type = vesselType.toLowerCase();
                if (type.includes('cargo') || type.includes('container')) return 'cargo';
                if (type.includes('tanker') || type.includes('oil')) return 'tanker';
                if (type.includes('passenger') || type.includes('ferry')) return 'passenger';
                return 'other';
            }
            
            getShipCount() {
                return this.shipData.size;
            }
            
            getVisibleShipCount() {
                let count = 0;
                for (const [mmsi, shipData] of this.shipData.entries()) {
                    if (this.isShipTypeVisible(shipData.vesselType)) {
                        count++;
                    }
                }
                return count;
            }
        }
        
        // AIS Message Processor
        class AISMessageProcessor {
            constructor(dataManager) {
                this.dataManager = dataManager;
                this.boundingBox = AIS_CONFIG.BOUNDING_BOX;
            }
            
            processMessage(data) {
                try {
                    // Validate message structure
                    if (!data || !data.Message) {
                        return;
                    }
                    
                    const message = data.Message;
                    
                    // Only process position reports
                    if (!message.PositionReport) {
                        return;
                    }
                    
                    // Extract ship data
                    const shipData = this.extractShipData(message);
                    
                    if (shipData && this.validateShipData(shipData) && this.isWithinBounds(shipData)) {
                        this.dataManager.addOrUpdateShip(shipData);
                    }
                } catch (error) {
                    console.error('AIS message processing error:', error);
                }
            }
            
            extractShipData(message) {
                try {
                    const positionReport = message.PositionReport;
                    const metaData = message.MetaData || {};
                    const shipAndCargoType = metaData.ShipAndCargoType || {};
                    
                    // Create ship data object
                    const shipData = new AISShipData(
                        message.UserID ? message.UserID.toString() : null,
                        shipAndCargoType.ShipName || `Ship ${message.UserID}`,
                        positionReport.Latitude,
                        positionReport.Longitude,
                        positionReport.SpeedOverGround || 0,
                        positionReport.TrueHeading || positionReport.CourseOverGround || 0,
                        this.parseVesselType(shipAndCargoType.ShipAndCargoType),
                        new Date(metaData.time_utc || Date.now())
                    );
                    
                    return shipData;
                } catch (error) {
                    console.error('Error extracting ship data:', error);
                    return null;
                }
            }
            
            parseVesselType(shipAndCargoType) {
                if (!shipAndCargoType) return 'unknown';
                
                // AIS vessel type codes mapping
                const vesselTypes = {
                    // Cargo ships
                    70: 'cargo', 71: 'cargo', 72: 'cargo', 73: 'cargo', 74: 'cargo',
                    75: 'cargo', 76: 'cargo', 77: 'cargo', 78: 'cargo', 79: 'cargo',
                    
                    // Tankers
                    80: 'tanker', 81: 'tanker', 82: 'tanker', 83: 'tanker', 84: 'tanker',
                    85: 'tanker', 86: 'tanker', 87: 'tanker', 88: 'tanker', 89: 'tanker',
                    
                    // Passenger ships
                    60: 'passenger', 61: 'passenger', 62: 'passenger', 63: 'passenger',
                    64: 'passenger', 65: 'passenger', 66: 'passenger', 67: 'passenger',
                    68: 'passenger', 69: 'passenger',
                    
                    // Other vessels
                    30: 'fishing', 31: 'towing', 32: 'towing', 33: 'other', 34: 'diving',
                    35: 'military', 36: 'sailing', 37: 'pleasure'
                };
                
                const vesselType = vesselTypes[shipAndCargoType] || 'other';
                return vesselType;
            }
            
            validateShipData(shipData) {
                // Basic validation
                if (!shipData.mmsi) {
                    return false;
                }
                
                // Check coordinates
                if (isNaN(shipData.latitude) || isNaN(shipData.longitude)) {
                    return false;
                }
                
                // Check coordinate ranges
                if (shipData.latitude < -90 || shipData.latitude > 90) {
                    return false;
                }
                
                if (shipData.longitude < -180 || shipData.longitude > 180) {
                    return false;
                }
                
                // Check speed (reasonable range)
                if (shipData.speed < 0 || shipData.speed > 50) {
                    shipData.speed = Math.max(0, Math.min(50, shipData.speed));
                }
                
                // Check heading
                if (shipData.heading < 0 || shipData.heading >= 360) {
                    shipData.heading = ((shipData.heading % 360) + 360) % 360;
                }
                
                return true;
            }
            
            isWithinBounds(shipData) {
                const [minLat, minLon, maxLat, maxLon] = this.boundingBox;
                
                return shipData.latitude >= minLat &&
                       shipData.latitude <= maxLat &&
                       shipData.longitude >= minLon &&
                       shipData.longitude <= maxLon;
            }
            
            setBoundingBox(boundingBox) {
                this.boundingBox = boundingBox;
            }
        }
        
        // AIS Marker Manager
        class AISMarkerManager {
            constructor() {
                this.vesselTypeColors = {
                    'cargo': '#2196F3',
                    'tanker': '#F44336',
                    'passenger': '#4CAF50',
                    'fishing': '#FF9800',
                    'military': '#795548',
                    'other': '#9E9E9E'
                };
            }
            
            createShipMarker(shipData) {
                const color = this.getShipColor(shipData.vesselType);
                const rotation = shipData.heading || 0;
                const vesselType = shipData.vesselType || 'other';
                
                // Create custom div icon with rotation
                const marker = L.divIcon({
                    className: `ais-ship-marker ${vesselType}`,
                    html: `<div class="ais-ship-icon" style="transform: rotate(${rotation}deg);">‚¨Ü</div>`,
                    iconSize: [16, 16],
                    iconAnchor: [8, 8],
                    popupAnchor: [0, -8]
                });
                
                // Create Leaflet marker
                const leafletMarker = L.marker([shipData.latitude, shipData.longitude], {
                    icon: marker,
                    title: shipData.shipName,
                    alt: `AIS Ship: ${shipData.shipName}`,
                    riseOnHover: true
                });
                
                // Add popup
                const popupContent = this.createPopupContent(shipData);
                leafletMarker.bindPopup(popupContent, {
                    maxWidth: 300,
                    minWidth: 200,
                    offset: [0, -8],
                    className: 'ais-ship-popup'
                });
                
                // Store ship data reference
                leafletMarker._aisData = shipData;
                
                return leafletMarker;
            }
            
            createPopupContent(shipData) {
                const formatSpeed = (speed) => speed ? `${speed.toFixed(1)} knots` : 'N/A';
                const formatHeading = (heading) => heading ? `${heading}¬∞` : 'N/A';
                const formatTime = (timestamp) => {
                    if (!timestamp) return 'N/A';
                    const date = new Date(timestamp);
                    return date.toLocaleTimeString('tr-TR', {
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                };
                
                const formatVesselType = (type) => {
                    const types = {
                        'cargo': 'Kargo Gemisi',
                        'tanker': 'Tanker',
                        'passenger': 'Yolcu Gemisi',
                        'fishing': 'Balƒ±k√ßƒ± Teknesi',
                        'military': 'Askeri Gemi',
                        'other': 'Diƒüer'
                    };
                    return types[type] || 'Bilinmeyen';
                };
                
                return `
                    <div class="ais-popup-content">
                        <div class="popup-header">
                            <strong>üö¢ ${shipData.shipName}</strong>
                        </div>
                        <div class="popup-info">
                            <div class="info-row">
                                <span class="label">üìç Konum:</span>
                                <span class="value">${shipData.latitude.toFixed(4)}, ${shipData.longitude.toFixed(4)}</span>
                            </div>
                            <div class="info-row">
                                <span class="label">‚ö° Hƒ±z:</span>
                                <span class="value">${formatSpeed(shipData.speed)}</span>
                            </div>
                            <div class="info-row">
                                <span class="label">üß≠ Y√∂n:</span>
                                <span class="value">${formatHeading(shipData.heading)}</span>
                            </div>
                            <div class="info-row">
                                <span class="label">üìã Tip:</span>
                                <span class="value">${formatVesselType(shipData.vesselType)}</span>
                            </div>
                            <div class="info-row">
                                <span class="label">üÜî MMSI:</span>
                                <span class="value">${shipData.mmsi}</span>
                            </div>
                            <div class="info-row">
                                <span class="label">‚è∞ G√ºncelleme:</span>
                                <span class="value">${formatTime(shipData.timestamp)}</span>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            updateMarkerRotation(marker, heading) {
                if (!marker || !marker.getElement()) return;
                
                const iconElement = marker.getElement();
                const shipIcon = iconElement.querySelector('.ais-ship-icon');
                
                if (shipIcon) {
                    shipIcon.style.transform = `rotate(${heading || 0}deg)`;
                }
            }
            
            updateMarkerPosition(marker, latitude, longitude) {
                if (marker) {
                    marker.setLatLng([latitude, longitude]);
                }
            }
            
            getShipColor(vesselType) {
                return this.vesselTypeColors[vesselType] || this.vesselTypeColors.other;
            }
            
            getShipIcon(vesselType) {
                // Different icons for different vessel types
                const icons = {
                    'cargo': '‚¨Ü',
                    'tanker': '‚¨Ü',
                    'passenger': '‚¨Ü',
                    'fishing': '‚¨Ü',
                    'military': '‚¨Ü',
                    'other': '‚¨Ü'
                };
                return icons[vesselType] || icons.other;
            }
        }
        
        // AIS UI Manager
        class AISUIManager {
            constructor() {
                this.statusIndicator = document.getElementById('aisStatusIndicator');
                this.statusDisplay = document.getElementById('aisStatusDisplay');
                this.toggleContainer = document.getElementById('aisToggleContainer');
                this.filterSection = document.getElementById('shipFilterSection');
            }
            
            updateConnectionStatus(status, message, shipCount = 0) {
                // Update status indicator
                if (this.statusIndicator) {
                    this.statusIndicator.className = `ais-status-indicator ${status}`;
                }
                
                // Update status display
                if (this.statusDisplay) {
                    let displayMessage = message;
                    
                    switch (status) {
                        case 'connecting':
                            displayMessage = 'üîÑ ' + message;
                            break;
                        case 'connected':
                            displayMessage = `‚úÖ AIS Aktif - ${shipCount} gemi`;
                            break;
                        case 'demo':
                            displayMessage = 'üé≠ ' + message;
                            break;
                        case 'disconnected':
                            displayMessage = '‚ùå AIS Baƒülantƒ±sƒ± kapalƒ±';
                            break;
                        case 'error':
                            displayMessage = '‚ö†Ô∏è ' + message;
                            break;
                        case 'no_data':
                            displayMessage = 'üì° B√∂lgede gemi bulunamadƒ±';
                            break;
                    }
                    
                    this.statusDisplay.textContent = displayMessage;
                    this.statusDisplay.style.color = this.getStatusColor(status);
                }
                
                // Show/hide filter section based on connection status
                if (this.filterSection) {
                    this.filterSection.style.display = status === 'connected' ? 'block' : 'none';
                }
            }
            
            getStatusColor(status) {
                const colors = {
                    'connecting': '#ff9800',
                    'connected': '#4caf50',
                    'demo': '#2196F3',
                    'disconnected': '#666',
                    'error': '#f44336',
                    'no_data': '#9e9e9e'
                };
                return colors[status] || '#666';
            }
            
            showErrorMessage(message, duration = 5000) {
                // Create temporary error notification
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 120px;
                    right: 20px;
                    background: linear-gradient(135deg, rgba(244, 67, 54, 0.95), rgba(211, 47, 47, 0.95));
                    color: white;
                    padding: 12px 16px;
                    border-radius: 8px;
                    font-family: 'Courier New', monospace;
                    font-size: 11px;
                    z-index: 2000;
                    max-width: 250px;
                    word-wrap: break-word;
                    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
                    animation: slideInRight 0.3s ease;
                `;
                
                notification.textContent = message;
                document.body.appendChild(notification);
                
                // Auto-remove notification
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.style.animation = 'slideOutRight 0.3s ease';
                        setTimeout(() => {
                            if (notification.parentNode) {
                                document.body.removeChild(notification);
                            }
                        }, 300);
                    }
                }, duration);
            }
            
            updateShipCount(count) {
                if (this.statusDisplay && this.statusDisplay.textContent.includes('AIS Aktif')) {
                    this.updateConnectionStatus('connected', '', count);
                }
            }
        }
        
        // Ship class for managing individual ships
        class Ship {
            constructor(id, name, color, defaultSpeed, defaultDirection, defaultPosition) {
                this.id = id;
                this.name = name;
                this.color = color;
                this.speed = defaultSpeed;
                this.direction = defaultDirection;
                this.marker = null;
                this.customStartPosition = null;
                this.customStartTime = 0;
                this.defaultPosition = defaultPosition; // 'north' or 'south'
            }
            
            getStartingWaypoints() {
                if (this.direction === 'northbound') {
                    return [...SHIP_ROUTE_COORDINATES].reverse();
                } else {
                    return [...SHIP_ROUTE_COORDINATES];
                }
            }
            
            getStartingPosition() {
                const waypoints = this.getStartingWaypoints();
                return this.defaultPosition === 'south' ? 
                    waypoints[0] : waypoints[waypoints.length - 1];
            }
        }
        
        // Initialize two ships - both starting northbound from south
        const ships = [
            new Ship('own', 'OWN SHIP', '#2196F3', 8, 'northbound', 'south'),
            new Ship('other', 'OTHER SHIP', '#FF9800', 10, 'northbound', 'south')
        ];
        
        // Ship route coordinates (using TSS center line Points 3-23)
        const SHIP_ROUTE_COORDINATES = [
            [41.225717, 29.132567], // Point 3
            [41.202050, 29.113400], // Point 10
            [41.180383, 29.084233], // Point 11
            [41.155383, 29.058383], // Point 12
            [41.147733, 29.058383], // Point 13
            [41.122050, 29.082900], // Point 14
            [41.119217, 29.082900], // Point 15
            [41.105383, 29.063067], // Point 16
            [41.099050, 29.060733], // Point 17
            [41.082050, 29.060400], // Point 18
            [41.074550, 29.052400], // Point 19
            [41.050717, 29.042883], // Point 20
            [41.024883, 28.998067], // Point 21
            [41.022383, 28.996233], // Point 22
            [41.001550, 28.995400]  // Point 23
        ];
        
        // Boundary coordinates to restrict panning (expanded for full strait coverage)
        const SOUTHWEST_BOUND = [40.90, 28.80];
        const NORTHEAST_BOUND = [41.25, 29.40];
        const MAP_BOUNDS = [SOUTHWEST_BOUND, NORTHEAST_BOUND];
        
        // Initialize the map
        const map = L.map('map', {
            center: ISTANBUL_STRAIT_CENTER,
            zoom: INITIAL_ZOOM,
            minZoom: MIN_ZOOM,
            maxZoom: MAX_ZOOM,
            maxBounds: MAP_BOUNDS,
            maxBoundsViscosity: 1.0,
            zoomControl: true,
            attributionControl: false
        });
        
        // Position zoom control
        map.zoomControl.setPosition('topright');
        
        // Base layer - Use a clean water-focused tile source
        const baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: MAX_ZOOM,
            minZoom: MIN_ZOOM,
            opacity: 0.8,
            attribution: ''
        }).addTo(map);
        
        // Manual Traffic Separation Scheme Layer Group
        let tssLayerGroup = L.layerGroup();
        
        // OpenSeaMap overlay for faint background option
        const openSeaMapOverlay = L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
            maxZoom: MAX_ZOOM,
            minZoom: MIN_ZOOM,
            opacity: 0.1,
            attribution: ''
        });
        
        // Istanbul Strait Traffic Separation Scheme - Complete 3-Line System
        // Source: Official Maritime Traffic Regulations for the Turkish Straits
        // All coordinates converted to decimal degrees (WGS-84)
        const istanbulStraitTSS = {
            // TSS Center Line (Points 3, 10-23) - The official separation line
            centerLine: [
                [41.225717, 29.132567], // Point 3:  41¬∞13'.543 N, 29¬∞07'.954 E
                [41.202050, 29.113400], // Point 10: 41¬∞12'.123 N, 29¬∞06'.804 E
                [41.180383, 29.084233], // Point 11: 41¬∞10'.823 N, 29¬∞05'.054 E
                [41.155383, 29.058383], // Point 12: 41¬∞09'.323 N, 29¬∞03'.503 E
                [41.147733, 29.058383], // Point 13: 41¬∞08'.864 N, 29¬∞03'.503 E
                [41.122050, 29.082900], // Point 14: 41¬∞07'.323 N, 29¬∞04'.974 E
                [41.119217, 29.082900], // Point 15: 41¬∞07'.153 N, 29¬∞04'.974 E
                [41.105383, 29.063067], // Point 16: 41¬∞06'.323 N, 29¬∞03'.784 E
                [41.099050, 29.060733], // Point 17: 41¬∞05'.943 N, 29¬∞03'.644 E
                [41.082050, 29.060400], // Point 18: 41¬∞04'.923 N, 29¬∞03'.624 E
                [41.074550, 29.052400], // Point 19: 41¬∞04'.473 N, 29¬∞03'.144 E
                [41.050717, 29.042883], // Point 20: 41¬∞03'.043 N, 29¬∞02'.573 E
                [41.024883, 28.998067], // Point 21: 41¬∞01'.493 N, 28¬∞59'.884 E
                [41.022383, 28.996233], // Point 22: 41¬∞01'.343 N, 28¬∞59'.774 E
                [41.001550, 28.995400]  // Point 23: 41¬∞00'.093 N, 28¬∞59'.724 E
            ],
            
            // Eastern Boundary Line (Points 24-38, 6) - Right side boundary
            easternBoundary: [
                [40.999050, 29.000567], // Point 24: 40¬∞59'.943 N, 29¬∞00'.034 E
                [41.017383, 29.000733], // Point 25: 41¬∞01'.043 N, 29¬∞00'.044 E
                [41.024050, 29.002917], // Point 26: 41¬∞01'.443 N, 29¬∞00'.175 E
                [41.050717, 29.048900], // Point 27: 41¬∞03'.043 N, 29¬∞02'.934 E
                [41.074050, 29.055067], // Point 28: 41¬∞04'.443 N, 29¬∞03'.304 E
                [41.081883, 29.064883], // Point 29: 41¬∞04'.913 N, 29¬∞03'.893 E
                [41.099883, 29.063717], // Point 30: 41¬∞05'.993 N, 29¬∞03'.823 E
                [41.104900, 29.066217], // Point 31: 41¬∞06'.294 N, 29¬∞03'.973 E
                [41.119050, 29.089550], // Point 32: 41¬∞07'.143 N, 29¬∞05'.373 E
                [41.122383, 29.088733], // Point 33: 41¬∞07'.343 N, 29¬∞05'.324 E
                [41.146550, 29.064400], // Point 34: 41¬∞08'.793 N, 29¬∞03'.864 E
                [41.157050, 29.063550], // Point 35: 41¬∞09'.423 N, 29¬∞03'.813 E
                [41.179050, 29.086233], // Point 36: 41¬∞10'.743 N, 29¬∞05'.174 E
                [41.193550, 29.112567], // Point 37: 41¬∞11'.613 N, 29¬∞06'.754 E
                [41.204050, 29.119567], // Point 38: 41¬∞12'.243 N, 29¬∞07'.174 E
                [41.221717, 29.142067]  // Point 6:  41¬∞13'.303 N, 29¬∞08'.524 E
            ],
            
            // Western Boundary Line (Points 9, 39-53) - Left side boundary
            westernBoundary: [
                [41.228950, 29.124567], // Point 9:  41¬∞13'.743 N, 29¬∞07'.474 E
                [41.204050, 29.110067], // Point 39: 41¬∞12'.243 N, 29¬∞06'.604 E
                [41.199050, 29.099567], // Point 40: 41¬∞11'.943 N, 29¬∞05'.974 E
                [41.174217, 29.074567], // Point 41: 41¬∞10'.453 N, 29¬∞04'.474 E
                [41.157717, 29.054383], // Point 42: 41¬∞09'.463 N, 29¬∞03'.263 E
                [41.149550, 29.054067], // Point 43: 41¬∞08'.973 N, 29¬∞03'.244 E
                [41.123733, 29.076550], // Point 44: 41¬∞07'.424 N, 29¬∞04'.593 E
                [41.103217, 29.057900], // Point 45: 41¬∞06'.193 N, 29¬∞03'.474 E
                [41.084550, 29.058383], // Point 46: 41¬∞05'.073 N, 29¬∞03'.503 E
                [41.081050, 29.056233], // Point 47: 41¬∞04'.863 N, 29¬∞03'.374 E
                [41.075217, 29.048567], // Point 48: 41¬∞04'.513 N, 29¬∞02'.914 E
                [41.067883, 29.047067], // Point 49: 41¬∞04'.073 N, 29¬∞02'.824 E
                [41.048550, 29.034083], // Point 50: 41¬∞02'.913 N, 29¬∞02'.045 E
                [41.027883, 28.995067], // Point 51: 41¬∞01'.673 N, 28¬∞59'.704 E
                [41.020550, 28.990400], // Point 52: 41¬∞01'.233 N, 28¬∞59'.424 E
                [41.004050, 28.989900]  // Point 53: 41¬∞00'.243 N, 28¬∞59'.394 E
            ]
        };
        
        // Clean water-focused base layer
        const cleanWaterLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png', {
            maxZoom: MAX_ZOOM,
            minZoom: MIN_ZOOM,
            opacity: 0.8,
            attribution: ''
        });
        
        // Enhanced base layer for better contrast
        const enhancedBase = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
            maxZoom: MAX_ZOOM,
            minZoom: MIN_ZOOM,
            opacity: 1.0,
            attribution: ''
        });
        
        // Alternative cleaner base layer for better water contrast
        const waterLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
            maxZoom: MAX_ZOOM,
            minZoom: MIN_ZOOM,
            opacity: 1.0,
            attribution: ''
        });
        
        // Add clean water base layer
        cleanWaterLayer.addTo(map);
        enhancedBase.addTo(map);
        
        // Function to create manual Istanbul Strait Traffic Separation Scheme
        function createManualTSS() {
            updateStatus('Loading official Istanbul Strait Traffic Separation lines...');
            
            // Clear existing TSS layer
            tssLayerGroup.clearLayers();
            
            // Style for the center separation line
            const centerLineStyle = {
                color: '#eb66c8',        // Soft Pink
                weight: 8,               // Thick line (unchanged)
                opacity: 0.9,
                dashArray: null          // Continuous line
            };
            
            // Style for the eastern boundary line
            const easternBoundaryStyle = {
                color: '#eb66c8',        // Soft Pink
                weight: 3,               // Much thinner line
                opacity: 0.9,
                dashArray: '10, 5'       // Short intermittent dashes
            };
            
            // Style for the western boundary line
            const westernBoundaryStyle = {
                color: '#eb66c8',        // Soft Pink
                weight: 3,               // Much thinner line
                opacity: 0.9,
                dashArray: '10, 5'       // Short intermittent dashes
            };
            
            // Create Center Line as thick polyline
            const centerLine = L.polyline(istanbulStraitTSS.centerLine, centerLineStyle)
                .bindPopup(`
                    <div style="font-family: 'Courier New', monospace; font-size: 12px;">
                        <strong>TSS CENTER LINE</strong><br>
                        <em>Traffic Separation Center</em><br>
                        <hr style="margin: 5px 0;">
                        üö´ <strong>Transit:</strong> Prohibited<br>
                        ‚ö†Ô∏è <strong>Purpose:</strong> Traffic separation<br>
                        üìè <strong>Points:</strong> 15 official coordinates<br>
                        üìã <strong>Authority:</strong> Turkish Maritime<br>
                        üó∫Ô∏è <strong>Source:</strong> Official TSS Regulations
                    </div>
                `);
            
            // Create Eastern Boundary Line as thick polyline
            const easternBoundaryLine = L.polyline(istanbulStraitTSS.easternBoundary, easternBoundaryStyle)
                .bindPopup(`
                    <div style="font-family: 'Courier New', monospace; font-size: 12px;">
                        <strong>EASTERN BOUNDARY</strong><br>
                        <em>Traffic Lane Eastern Limit</em><br>
                        <hr style="margin: 5px 0;">
                        ‚û°Ô∏è <strong>Side:</strong> Asian (Eastern)<br>
                        üö¢ <strong>Function:</strong> Traffic boundary<br>
                        üìè <strong>Points:</strong> 16 official coordinates<br>
                        üìã <strong>Authority:</strong> Turkish Maritime<br>
                        üó∫Ô∏è <strong>Source:</strong> Official TSS Regulations
                    </div>
                `);
            
            // Create Western Boundary Line as thick polyline
            const westernBoundaryLine = L.polyline(istanbulStraitTSS.westernBoundary, westernBoundaryStyle)
                .bindPopup(`
                    <div style="font-family: 'Courier New', monospace; font-size: 12px;">
                        <strong>WESTERN BOUNDARY</strong><br>
                        <em>Traffic Lane Western Limit</em><br>
                        <hr style="margin: 5px 0;">
                        ‚¨ÖÔ∏è <strong>Side:</strong> European (Western)<br>
                        üö¢ <strong>Function:</strong> Traffic boundary<br>
                        üìè <strong>Points:</strong> 16 official coordinates<br>
                        üìã <strong>Authority:</strong> Turkish Maritime<br>
                        üó∫Ô∏è <strong>Source:</strong> Official TSS Regulations
                    </div>
                `);
            
            // Add lines to layer group
            tssLayerGroup.addLayer(centerLine);
            tssLayerGroup.addLayer(easternBoundaryLine);
            tssLayerGroup.addLayer(westernBoundaryLine);
            
            // Add to map
            tssLayerGroup.addTo(map);
            
            updateStatus('‚úì Istanbul Strait TSS complete 3-line system loaded successfully');
            updateInfoPanel('Manual Istanbul Strait TSS - Complete 3-Line System');
        }
        
        // Status update function
        function updateStatus(message) {
            // Status updates (can be removed if not needed)
        }
        
        // Update info panel with chart source (simplified since panel removed)
        function updateInfoPanel(source) {
            // Info panel functionality removed for cleaner interface
        }
        
        // Initialize hybrid mode (Manual Istanbul Strait TSS + OpenSeaMap)
        createManualTSS();
        openSeaMapOverlay.setOpacity(0.3); // Default 30% opacity
        openSeaMapOverlay.addTo(map);
        
        // Hide loading indicator once base tiles are loaded
        let tilesLoaded = false;
        let mapReady = false;
        
        function checkAndHideLoading() {
            if (tilesLoaded && mapReady) {
                document.getElementById('loading').classList.add('hidden');
            }
        }
        
        // Map container is ready
        map.whenReady(function() {
            mapReady = true;
            checkAndHideLoading();
        });
        
        // Base layer tiles are loaded
        baseLayer.on('load', function() {
            tilesLoaded = true;
            checkAndHideLoading();
        });
        
        // Fallback: Hide loading after maximum 800ms if events don't fire
        setTimeout(() => {
            document.getElementById('loading').classList.add('hidden');
        }, 800);
        
        // Prevent map from being dragged outside bounds
        map.on('drag', function() {
            map.panInsideBounds(MAP_BOUNDS, { animate: false });
        });
        

        
        // Handle tile loading errors gracefully
        cleanWaterLayer.on('tileerror', function(e) {
            // Handle tile loading errors if needed
        });
        
        enhancedBase.on('tileerror', function(e) {
            // Handle tile loading errors if needed
        });
        
        // Initialize hybrid mode (TSS + OpenSeaMap) directly
        createManualTSS();
        openSeaMapOverlay.setOpacity(0.3); // Default 30%
        openSeaMapOverlay.addTo(map);
        
        // Add event listeners for map interactions
        map.on('zoomend', function() {
            const currentZoom = map.getZoom();
            
            // Adjust TSS opacity based on zoom level for better visibility
            if (map.hasLayer(tssLayerGroup)) {
                const opacity = currentZoom >= 13 ? 1.0 : currentZoom >= 11 ? 0.8 : 0.6;
                tssLayerGroup.eachLayer(layer => {
                    if (layer.setStyle) {
                        const currentStyle = layer.options;
                        layer.setStyle({
                            ...currentStyle,
                            opacity: opacity,
                            fillOpacity: currentStyle.fillOpacity * opacity
                        });
                    }
                });
            }
        });
        
        map.on('moveend', function() {
            // Map movement handling if needed
        });
        
        // Add coordinate display for georeferencing verification
        const coordinateDisplay = document.getElementById('coordinates');
        
        map.on('mousemove', function(e) {
            const lat = e.latlng.lat.toFixed(5);
            const lng = e.latlng.lng.toFixed(5);
            coordinateDisplay.innerHTML = `Lat: ${lat} Lng: ${lng}`;
        });
        
        map.on('mouseout', function() {
            coordinateDisplay.innerHTML = 'Lat: --.----- Lng: ---.-----';
        });
        
        // Optimize map performance
        map.options.preferCanvas = true;
        
        // ===== AIS SYSTEM INITIALIZATION =====
        
        // Initialize AIS system components
        const aisUIManager = new AISUIManager();
        const aisMarkerManager = new AISMarkerManager();
        const aisDataManager = new AISDataManager();
        const aisMessageProcessor = new AISMessageProcessor(aisDataManager);
        const aisConnectionManager = new AISConnectionManager();
        
        // Set up component dependencies
        aisDataManager.setMarkerManager(aisMarkerManager);
        aisConnectionManager.setUIManager(aisUIManager);
        aisConnectionManager.setDataManager(aisDataManager);
        aisConnectionManager.setMessageCallback((data) => {
            aisMessageProcessor.processMessage(data);
            // Update ship count in UI
            const shipCount = aisDataManager.getVisibleShipCount();
            aisUIManager.updateShipCount(shipCount);
        });
        
        // Add AIS layer to map
        aisDataManager.addToMap(map);
        
        // AIS Toggle Event Handler
        function toggleAIS() {
            const toggle = document.getElementById('aisToggleInput');
            const mobileToggle = document.getElementById('mobileAISToggle');
            
            const isEnabled = toggle.checked;
            
            // Sync mobile toggle
            if (mobileToggle) {
                mobileToggle.checked = isEnabled;
            }
            
            if (isEnabled) {
                aisConnectionManager.enable();
                aisDataManager.startCleanupProcess();
                console.log('AIS tracking enabled');
            } else {
                aisConnectionManager.disable();
                aisDataManager.stopCleanupProcess();
                console.log('AIS tracking disabled');
            }
        }
        
        // Mobile AIS Toggle Event Handler
        function toggleMobileAIS() {
            const toggle = document.getElementById('aisToggleInput');
            const mobileToggle = document.getElementById('mobileAISToggle');
            
            const isEnabled = mobileToggle.checked;
            
            // Sync main toggle
            if (toggle) {
                toggle.checked = isEnabled;
            }
            
            if (isEnabled) {
                aisConnectionManager.enable();
                aisDataManager.startCleanupProcess();
                console.log('AIS tracking enabled (mobile)');
            } else {
                aisConnectionManager.disable();
                aisDataManager.stopCleanupProcess();
                console.log('AIS tracking disabled (mobile)');
            }
        }
        
        // Ship Filter Event Handlers
        function updateShipFilters() {
            const cargoFilter = document.getElementById('cargoFilter');
            const tankerFilter = document.getElementById('tankerFilter');
            const passengerFilter = document.getElementById('passengerFilter');
            const otherFilter = document.getElementById('otherFilter');
            
            const filters = {
                cargo: cargoFilter ? cargoFilter.checked : true,
                tanker: tankerFilter ? tankerFilter.checked : true,
                passenger: passengerFilter ? passengerFilter.checked : true,
                other: otherFilter ? otherFilter.checked : true
            };
            
            aisDataManager.updateFilters(filters);
            
            // Update ship count in UI
            const shipCount = aisDataManager.getVisibleShipCount();
            aisUIManager.updateShipCount(shipCount);
        }
        
        // Attach AIS event listeners when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Main AIS toggle
            const aisToggle = document.getElementById('aisToggleInput');
            if (aisToggle) {
                aisToggle.addEventListener('change', toggleAIS);
            }
            
            // Mobile AIS toggle
            const mobileAISToggle = document.getElementById('mobileAISToggle');
            if (mobileAISToggle) {
                mobileAISToggle.addEventListener('change', toggleMobileAIS);
            }
            
            // Ship filter checkboxes
            const filterIds = ['cargoFilter', 'tankerFilter', 'passengerFilter', 'otherFilter'];
            filterIds.forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox) {
                    checkbox.addEventListener('change', updateShipFilters);
                }
            });
        });
        
        // Global AIS functions for external access
        window.aisSystem = {
            connectionManager: aisConnectionManager,
            dataManager: aisDataManager,
            uiManager: aisUIManager,
            toggleAIS: toggleAIS,
            updateFilters: updateShipFilters
        };
        
        // AIS and Ship Simulation Integration Safety
        function ensureLayerSeparation() {
            // Ensure AIS layer is below simulation ships
            if (aisDataManager.aisLayerGroup && map.hasLayer(aisDataManager.aisLayerGroup)) {
                aisDataManager.aisLayerGroup.setZIndex(900);
            }
            
            // Ensure simulation ship markers stay on top
            ships.forEach(ship => {
                if (ship.marker && map.hasLayer(ship.marker)) {
                    const markerElement = ship.marker.getElement();
                    if (markerElement) {
                        markerElement.style.zIndex = '1000';
                    }
                }
            });
        }
        
        // Call layer separation periodically
        setInterval(ensureLayerSeparation, 5000);
        
        // Override ship simulation toggle to ensure AIS compatibility
        const originalToggleShipSimulation = window.toggleShipSimulation;
        window.toggleShipSimulation = function() {
            if (typeof originalToggleShipSimulation === 'function') {
                originalToggleShipSimulation();
            }
            // Ensure layer separation after simulation toggle
            setTimeout(ensureLayerSeparation, 100);
        };
        
        // Ship Simulation Functions
        
        // Calculate distance between two points in nautical miles
        function calculateDistance(lat1, lng1, lat2, lng2) {
            const R = 3440.065; // Earth's radius in nautical miles
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                     Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                     Math.sin(dLng/2) * Math.sin(dLng/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // Calculate bearing between two points
        function calculateBearing(lat1, lng1, lat2, lng2) {
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const lat1Rad = lat1 * Math.PI / 180;
            const lat2Rad = lat2 * Math.PI / 180;
            const y = Math.sin(dLng) * Math.cos(lat2Rad);
            const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - 
                     Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLng);
            const bearing = Math.atan2(y, x) * 180 / Math.PI;
            return (bearing + 360) % 360;
        }
        
        // Initialize ship route calculations for a specific ship
        function initializeShipRoute(ship) {
            // Set route waypoints based on direction
            const shipWaypoints = ship.getStartingWaypoints();
            
            routeWaypoints = shipWaypoints;
            routeDistances = [];
            totalRouteDistance = 0;
            
            // Validate waypoints
            if (routeWaypoints.length < 2) {
                console.error('Not enough waypoints for route calculation');
                return;
            }
            
            // Calculate distances between consecutive waypoints
            for (let i = 0; i < routeWaypoints.length - 1; i++) {
                const dist = calculateDistance(
                    routeWaypoints[i][0], routeWaypoints[i][1],
                    routeWaypoints[i + 1][0], routeWaypoints[i + 1][1]
                );
                
                // Validate distance calculation
                if (isNaN(dist) || dist <= 0) {
                    console.warn(`Invalid distance calculated for segment ${i}: ${dist}`);
                    routeDistances.push(0.1); // Fallback to small distance
                } else {
                    routeDistances.push(dist);
                }
                
                totalRouteDistance += routeDistances[i];
            }
            
            console.log(`Route initialized for ${ship.name} (${ship.direction}): ${routeWaypoints.length} waypoints`);
            console.log(`Starting position: [${routeWaypoints[0][0].toFixed(5)}, ${routeWaypoints[0][1].toFixed(5)}]`);
            console.log(`Ending position: [${routeWaypoints[routeWaypoints.length-1][0].toFixed(5)}, ${routeWaypoints[routeWaypoints.length-1][1].toFixed(5)}]`);
            console.log(`Total distance: ${totalRouteDistance.toFixed(3)} nm`);
        }
        
        // Get ship position at a given time for a specific ship
        function getShipPositionAtTime(ship, timeMinutes) {
            const speedNauticalMilesPerMinute = ship.speed / 60;
            let targetDistance = timeMinutes * speedNauticalMilesPerMinute;
            
            // Get ship's route waypoints
            const shipWaypoints = ship.getStartingWaypoints();
            
            // Calculate route distances for this ship if not cached
            let shipRouteDistances = [];
            let shipTotalDistance = 0;
            
            for (let i = 0; i < shipWaypoints.length - 1; i++) {
                const dist = calculateDistance(
                    shipWaypoints[i][0], shipWaypoints[i][1],
                    shipWaypoints[i + 1][0], shipWaypoints[i + 1][1]
                );
                shipRouteDistances.push(dist);
                shipTotalDistance += dist;
            }
            
            // If ship has been dragged to a custom position, calculate from that position
            if (ship.customStartPosition) {
                // Find the distance along route where the custom position is
                const customPositionDistance = findDistanceAlongRoute(ship.customStartPosition, shipWaypoints, shipRouteDistances);
                targetDistance = customPositionDistance + (timeMinutes - ship.customStartTime) * speedNauticalMilesPerMinute;
            }
            
            // Debug: Log calculations
            console.log(`${ship.name} - Time: ${timeMinutes}min, Speed: ${ship.speed}kts, Target Distance: ${targetDistance.toFixed(3)}nm, Total Route: ${shipTotalDistance.toFixed(3)}nm`);
            
            if (targetDistance <= 0 || shipWaypoints.length < 2) {
                const bearing = shipWaypoints.length > 1 ? calculateBearing(
                    shipWaypoints[0][0], shipWaypoints[0][1],
                    shipWaypoints[1][0], shipWaypoints[1][1]
                ) : 0;
                
                return {
                    position: shipWaypoints[0],
                    bearing: bearing,
                    segmentIndex: 0,
                    nextWaypoint: 1,
                    distanceToNext: shipRouteDistances[0] || 0,
                    eta: shipRouteDistances[0] ? (shipRouteDistances[0] / speedNauticalMilesPerMinute) : 0
                };
            }
            
            // Clamp target distance to prevent jumping beyond route
            const clampedDistance = Math.min(targetDistance, shipTotalDistance * 0.99); // Stay within 99% of total
            
            if (clampedDistance >= shipTotalDistance * 0.99) {
                const lastIndex = shipWaypoints.length - 1;
                const bearing = shipWaypoints.length > 1 ? calculateBearing(
                    shipWaypoints[lastIndex - 1][0], shipWaypoints[lastIndex - 1][1],
                    shipWaypoints[lastIndex][0], shipWaypoints[lastIndex][1]
                ) : 0;
                
                return {
                    position: shipWaypoints[lastIndex],
                    bearing: bearing,
                    segmentIndex: lastIndex - 1,
                    nextWaypoint: null,
                    distanceToNext: 0,
                    eta: 0
                };
            }
            
            // Find which segment the ship is on
            let accumulatedDistance = 0;
            for (let i = 0; i < shipRouteDistances.length; i++) {
                const segmentDistance = shipRouteDistances[i];
                const segmentEndDistance = accumulatedDistance + segmentDistance;
                
                if (clampedDistance <= segmentEndDistance) {
                    // Ship is on this segment
                    const segmentProgress = segmentDistance > 0 ? 
                        (clampedDistance - accumulatedDistance) / segmentDistance : 0;
                    
                    // Clamp progress to valid range
                    const clampedProgress = Math.max(0, Math.min(1, segmentProgress));
                    
                    const lat1 = shipWaypoints[i][0];
                    const lng1 = shipWaypoints[i][1];
                    const lat2 = shipWaypoints[i + 1][0];
                    const lng2 = shipWaypoints[i + 1][1];
                    
                    // Linear interpolation
                    const lat = lat1 + (lat2 - lat1) * clampedProgress;
                    const lng = lng1 + (lng2 - lng1) * clampedProgress;
                    
                    const bearing = calculateBearing(lat1, lng1, lat2, lng2);
                    const remainingSegmentDistance = segmentDistance * (1 - clampedProgress);
                    
                    console.log(`${ship.name} - Segment ${i}, Progress: ${clampedProgress.toFixed(3)}, Position: [${lat.toFixed(6)}, ${lng.toFixed(6)}]`);
                    
                    return {
                        position: [lat, lng],
                        bearing: bearing,
                        segmentIndex: i,
                        nextWaypoint: i + 1 < shipWaypoints.length ? i + 1 : null,
                        distanceToNext: remainingSegmentDistance,
                        eta: remainingSegmentDistance / speedNauticalMilesPerMinute
                    };
                }
                
                accumulatedDistance = segmentEndDistance;
            }
            
            // Fallback: return last position if calculations fail
            console.warn(`Position calculation fallback triggered for ${ship.name}`);
            const lastIndex = shipWaypoints.length - 1;
            return {
                position: shipWaypoints[lastIndex],
                bearing: 0,
                segmentIndex: lastIndex - 1,
                nextWaypoint: null,
                distanceToNext: 0,
                eta: 0
            };
        }
        
        // Create ship marker for a specific ship
        function createShipMarker(ship, position, bearing = 0) {
            // Create ship icon with appropriate class
            const shipIcon = L.divIcon({
                className: 'ship-marker-custom',
                html: `<div class="ship-marker ${ship.id}-ship"></div>`,
                iconSize: [24, 24],
                iconAnchor: [12, 12],
                popupAnchor: [0, -12]
            });
            
            const marker = L.marker(position, {
                icon: shipIcon,
                draggable: true,
                zIndexOffset: 1000,
                riseOnHover: true
            });
            
            // Add popup with ship information
            marker.bindPopup(`
                <div style="font-family: 'Courier New', monospace; font-size: 12px;">
                    <strong>‚öì ${ship.name}</strong><br>
                    <em>Route Simulation</em><br>
                    <hr style="margin: 5px 0;">
                    üìç <strong>Lat:</strong> ${position[0].toFixed(5)}¬∞<br>
                    üìç <strong>Lng:</strong> ${position[1].toFixed(5)}¬∞<br>
                    üß≠ <strong>Heading:</strong> ${bearing.toFixed(0)}¬∞<br>
                    üö¢ <strong>Status:</strong> In Transit<br>
                    üé® <strong>Color:</strong> ${ship.color}
                </div>
            `);
            
            // Handle dragging - constrain to route
            marker.on('drag', function(e) {
                const dragPosition = e.target.getLatLng();
                const constrainedPosition = findNearestPointOnRoute(dragPosition, ship.getStartingWaypoints());
                e.target.setLatLng(constrainedPosition);
            });
            
            marker.on('dragend', function(e) {
                const finalPosition = e.target.getLatLng();
                
                // Set this as the new custom starting position for this ship
                ship.customStartPosition = finalPosition;
                ship.customStartTime = currentTime;
                
                console.log(`${ship.name} dragged to new position: [${finalPosition.lat.toFixed(5)}, ${finalPosition.lng.toFixed(5)}]`);
                console.log(`Custom start time set to: ${ship.customStartTime} minutes`);
                
                updateShipInfoFromPosition(ship, finalPosition);
                
                // Update dynamic meeting point when ship is dragged
                updateDynamicMeetingPoint();
                updateSingleMeetingPoint();
                updateMeetingWarning();
            });
            
            // Apply initial rotation after marker is added to map
            marker.on('add', function() {
                setTimeout(() => {
                    const element = marker.getElement();
                    if (element) {
                        const shipDiv = element.querySelector('.ship-marker');
                        if (shipDiv) {
                            shipDiv.style.transform = `rotate(${bearing}deg)`;
                        }
                    }
                }, 100);
            });
            
            return marker;
        }
        
        // Find nearest point on route to a given position
        function findNearestPointOnRoute(position, waypoints = routeWaypoints) {
            let minDistance = Infinity;
            let nearestPoint = waypoints[0];
            
            // Check distance to each waypoint
            for (let i = 0; i < waypoints.length; i++) {
                const distance = calculateDistance(
                    position.lat, position.lng,
                    waypoints[i][0], waypoints[i][1]
                );
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestPoint = waypoints[i];
                }
            }
            
            // Check distance to each route segment
            for (let i = 0; i < waypoints.length - 1; i++) {
                const segmentStart = waypoints[i];
                const segmentEnd = waypoints[i + 1];
                const projectedPoint = projectPointOnSegment(position, segmentStart, segmentEnd);
                
                const distance = calculateDistance(
                    position.lat, position.lng,
                    projectedPoint[0], projectedPoint[1]
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestPoint = projectedPoint;
                }
            }
            
            return L.latLng(nearestPoint[0], nearestPoint[1]);
        }
        
        // Project a point onto a line segment
        function projectPointOnSegment(point, segmentStart, segmentEnd) {
            const dx = segmentEnd[1] - segmentStart[1];
            const dy = segmentEnd[0] - segmentStart[0];
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length === 0) return segmentStart;
            
            const t = Math.max(0, Math.min(1, 
                ((point.lng - segmentStart[1]) * dx + (point.lat - segmentStart[0]) * dy) / (length * length)
            ));
            
            return [
                segmentStart[0] + t * dy,
                segmentStart[1] + t * dx
            ];
        }
        
        // Find distance along route for a given position
        function findDistanceAlongRoute(position, waypoints = routeWaypoints, distances = routeDistances) {
            let minDistance = Infinity;
            let bestSegmentIndex = 0;
            let bestProgress = 0;
            
            // Check each route segment to find closest point
            for (let i = 0; i < waypoints.length - 1; i++) {
                const segmentStart = waypoints[i];
                const segmentEnd = waypoints[i + 1];
                const projectedPoint = projectPointOnSegment(position, segmentStart, segmentEnd);
                
                const distance = calculateDistance(
                    position.lat, position.lng,
                    projectedPoint[0], projectedPoint[1]
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    bestSegmentIndex = i;
                    
                    // Calculate progress along this segment
                    const segmentLength = calculateDistance(
                        segmentStart[0], segmentStart[1],
                        segmentEnd[0], segmentEnd[1]
                    );
                    
                    const progressLength = calculateDistance(
                        segmentStart[0], segmentStart[1],
                        projectedPoint[0], projectedPoint[1]
                    );
                    
                    bestProgress = segmentLength > 0 ? progressLength / segmentLength : 0;
                }
            }
            
            // Calculate total distance to this point along route
            let totalDistance = 0;
            for (let i = 0; i < bestSegmentIndex; i++) {
                totalDistance += distances[i];
            }
            totalDistance += distances[bestSegmentIndex] * bestProgress;
            
            return totalDistance;
        }
        
        // Calculate meeting points between two ships
        function calculateMeetingPoints() {
            const ownShip = ships[0];
            const otherShip = ships[1];
            const meetingThreshold = 0.0005; // degrees (~0.03 nautical miles)
            const timeStep = 0.5; // minutes
            const maxTime = 60; // minutes
            
            const meetings = [];
            
            for (let time = 0; time <= maxTime; time += timeStep) {
                const ownData = getShipPositionAtTime(ownShip, time);
                const otherData = getShipPositionAtTime(otherShip, time);
                
                const distance = calculateDistance(
                    ownData.position[0], ownData.position[1],
                    otherData.position[0], otherData.position[1]
                );
                
                // Convert distance to degrees (approximate)
                const distanceDegrees = distance / 60; // rough conversion
                
                if (distanceDegrees <= meetingThreshold) {
                    meetings.push({
                        time: time,
                        position: ownData.position,
                        distance: distance
                    });
                }
            }
            
            return meetings;
        }
        
        // Check if ships are currently meeting
        function areShipsMeeting() {
            const ownShip = ships[0];
            const otherShip = ships[1];
            const meetingThreshold = 0.0005; // degrees
            
            const ownData = getShipPositionAtTime(ownShip, currentTime);
            const otherData = getShipPositionAtTime(otherShip, currentTime);
            
            const distance = calculateDistance(
                ownData.position[0], ownData.position[1],
                otherData.position[0], otherData.position[1]
            );
            
            const distanceDegrees = distance / 60;
            return distanceDegrees <= meetingThreshold;
        }
        
        // Update meeting warning display
        function updateMeetingWarning() {
            const meetings = calculateMeetingPoints();
            const warningDiv = document.getElementById('meetingWarning');
            const meetingTimeDiv = document.getElementById('meetingTime');
            const nextMeetingSpan = document.getElementById('nextMeeting');
            
            if (meetings.length > 0) {
                const nextMeeting = meetings.find(m => m.time >= currentTime);
                
                if (nextMeeting) {
                    const timeToMeeting = nextMeeting.time - currentTime;
                    nextMeetingSpan.textContent = `+${nextMeeting.time.toFixed(1)} min`;
                    
                    if (timeToMeeting <= 2) {
                        warningDiv.style.display = 'block';
                        meetingTimeDiv.textContent = `Meeting in ${timeToMeeting.toFixed(1)} minutes`;
                        
                        // Apply warning style to ship markers
                        ships.forEach(ship => {
                            if (ship.marker) {
                                const element = ship.marker.getElement();
                                if (element) {
                                    const shipDiv = element.querySelector('.ship-marker');
                                    if (shipDiv) {
                                        shipDiv.classList.add('warning');
                                    }
                                }
                            }
                        });
                        warningActive = true;
                    } else {
                        warningDiv.style.display = 'none';
                        clearWarningStyles();
                        warningActive = false;
                    }
                } else {
                    nextMeetingSpan.textContent = 'None detected';
                    warningDiv.style.display = 'none';
                    clearWarningStyles();
                    warningActive = false;
                }
            } else {
                nextMeetingSpan.textContent = 'None detected';
                warningDiv.style.display = 'none';
                clearWarningStyles();
                warningActive = false;
            }
        }
        
        // Clear warning styles from ship markers
        function clearWarningStyles() {
            ships.forEach(ship => {
                if (ship.marker) {
                    const element = ship.marker.getElement();
                    if (element) {
                        const shipDiv = element.querySelector('.ship-marker');
                        if (shipDiv) {
                            shipDiv.classList.remove('warning');
                        }
                    }
                }
            });
        }
        
        // Create or update single meeting point marker on the map
        function updateSingleMeetingPoint() {
            // Clear existing single meeting marker
            if (singleMeetingMarker) {
                map.removeLayer(singleMeetingMarker);
                singleMeetingMarker = null;
            }
            
            const meetings = calculateMeetingPoints();
            
            if (meetings.length > 0) {
                // Find the nearest meeting point (earliest time)
                const nearestMeeting = meetings.reduce((nearest, current) => {
                    return current.time < nearest.time ? current : nearest;
                });
                
                // Create single meeting marker
                const meetingIcon = L.divIcon({
                    className: 'single-meeting-marker',
                    html: '<div class="single-meeting-marker"></div>',
                    iconSize: [28, 28],
                    iconAnchor: [14, 14]
                });
                
                singleMeetingMarker = L.marker(nearestMeeting.position, {
                    icon: meetingIcon,
                    zIndexOffset: 1000
                });
                
                // Add tooltip with meeting information
                singleMeetingMarker.bindPopup(`
                    <div style="font-family: 'Courier New', monospace; font-size: 11px; text-align: center;">
                        ‚ö†Ô∏è <strong>MEETING POINT</strong><br>
                        <hr style="margin: 3px 0;">
                        üï∞ <strong>Time:</strong> +${nearestMeeting.time} min<br>
                        üìç <strong>Position:</strong><br>
                        Lat: ${nearestMeeting.position[0].toFixed(5)}¬∞<br>
                        Lng: ${nearestMeeting.position[1].toFixed(5)}¬∞<br>
                        üìè <strong>Distance:</strong> ${nearestMeeting.distance.toFixed(4)} nm
                    </div>
                `);
                
                singleMeetingMarker.addTo(map);
                console.log(`Single meeting point updated at time +${nearestMeeting.time} min`);
            }
        }
        
        // Create or update dynamic meeting point marker (red dot)
        function updateDynamicMeetingPoint() {
            // Clear existing dynamic meeting marker
            if (dynamicMeetingMarker) {
                map.removeLayer(dynamicMeetingMarker);
                dynamicMeetingMarker = null;
            }
            
            const meetings = calculateMeetingPoints();
            
            if (meetings.length > 0) {
                // Find the nearest meeting point (earliest time)
                const nearestMeeting = meetings.reduce((nearest, current) => {
                    return current.time < nearest.time ? current : nearest;
                });
                
                // Create dynamic meeting marker with custom red styling
                const dynamicMeetingIcon = L.divIcon({
                    className: 'meeting-point-marker-container',
                    html: '<div class="meeting-point-marker"></div>',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12]
                });
                
                dynamicMeetingMarker = L.marker(nearestMeeting.position, {
                    icon: dynamicMeetingIcon,
                    zIndexOffset: 1100
                });
                
                // Add tooltip with meeting information
                dynamicMeetingMarker.bindPopup(`
                    <div style="font-family: 'Courier New', monospace; font-size: 12px; text-align: center;">
                        üî¥ <strong>MEETING POINT</strong><br>
                        <hr style="margin: 5px 0;">
                        üï∞ <strong>Time:</strong> +${nearestMeeting.time.toFixed(1)} min<br>
                        üìç <strong>Lat:</strong> ${nearestMeeting.position[0].toFixed(5)}¬∞<br>
                        üìç <strong>Lng:</strong> ${nearestMeeting.position[1].toFixed(5)}¬∞<br>
                        üìè <strong>Distance:</strong> ${nearestMeeting.distance.toFixed(3)} nm<br>
                        ‚ö†Ô∏è <strong>Ships will meet here!</strong>
                    </div>
                `);
                
                dynamicMeetingMarker.addTo(map);
                console.log(`Dynamic meeting point marker updated at time +${nearestMeeting.time} min`);
            }
        }

        
        // Update ship info from current position for a specific ship
        function updateShipInfoFromPosition(ship, position) {
            // Find time that corresponds to this position
            // This is a simplified approach - in reality you'd need more complex calculation
            const shipData = getShipPositionAtTime(ship, currentTime);
            // Ship-specific info update could be added here if needed
        }
        
        // Toggle ship simulation
        function toggleShipSimulation() {
            shipSimulationActive = !shipSimulationActive;
            const panel = document.getElementById('shipControlPanel');
            const toggle = document.getElementById('shipToggle');
            
            if (shipSimulationActive) {
                console.log('Activating dual ship simulation...');
                panel.classList.add('active');
                expandBottomSheet(); // Show control panel for configuration
                toggle.classList.add('active');
                
                // Show vertical time slider instead of header slider
                showVerticalTimeSlider();
                hideHeaderTimeSlider();
                hideFloatingTimeSlider();
                
                // Reset all ships
                ships.forEach(ship => {
                    ship.customStartPosition = null;
                    ship.customStartTime = 0;
                });
                
                currentTime = 0;
                document.getElementById('timeSlider').value = 0;
                document.getElementById('floatingTimeControl').value = 0;
                document.getElementById('headerTimeControl').value = 0;
                document.getElementById('mobileTimeSlider').value = 0;
                
                // Create both ships
                ships.forEach(ship => {
                    initializeShipRoute(ship);
                    
                    const initialData = getShipPositionAtTime(ship, 0);
                    console.log(`Creating ${ship.name} marker at:`, initialData.position, 'bearing:', initialData.bearing);
                    
                    ship.marker = createShipMarker(ship, initialData.position, initialData.bearing);
                    
                    if (ship.marker) {
                        ship.marker.addTo(map);
                        console.log(`${ship.name} marker added to map`);
                        
                        // Verify marker is on map
                        setTimeout(() => {
                            const element = ship.marker.getElement();
                            if (element) {
                                console.log(`${ship.name} marker element found in DOM:`, element);
                            } else {
                                console.error(`${ship.name} marker element not found in DOM`);
                            }
                        }, 500);
                    } else {
                        console.error(`Failed to create ${ship.name} marker`);
                    }
                });
                
                setupShipControls();
                setupHeaderTimeSlider();
                updateSingleMeetingPoint();
                updateMeetingWarning();
                updateHeaderTimeDisplay();
                
                // Manual control only - no auto-minimize
                // User will control panel state manually
                
            } else {
                console.log('Deactivating dual ship simulation...');
                panel.classList.remove('active');
                toggle.classList.remove('active');
                
                // Hide vertical time slider and show map title
                hideVerticalTimeSlider();
                hideHeaderTimeSlider();
                hideFloatingTimeSlider();
                
                // Reset all ships
                ships.forEach(ship => {
                    ship.customStartPosition = null;
                    ship.customStartTime = 0;
                    
                    if (ship.marker) {
                        map.removeLayer(ship.marker);
                        ship.marker = null;
                        console.log(`${ship.name} marker removed from map`);
                    }
                });
                
                // Clear single meeting point marker
                if (singleMeetingMarker) {
                    map.removeLayer(singleMeetingMarker);
                    singleMeetingMarker = null;
                }
                
                // Clear dynamic meeting point marker
                if (dynamicMeetingMarker) {
                    map.removeLayer(dynamicMeetingMarker);
                    dynamicMeetingMarker = null;
                }
                
                if (animationFrame) {
                    cancelAnimationFrame(animationFrame);
                    animationFrame = null;
                }
            }
        }
        
        // Setup ship control event listeners
        function setupShipControls() {
            const ownSpeedInput = document.getElementById('ownShipSpeed');
            const otherSpeedInput = document.getElementById('otherShipSpeed');
            const timeSlider = document.getElementById('timeSlider');
            const floatingTimeControl = document.getElementById('floatingTimeControl');
            const verticalTimeControl = document.getElementById('verticalTimeControl');
            
            ownSpeedInput.addEventListener('input', function(e) {
                const newSpeed = parseFloat(e.target.value);
                if (newSpeed >= 1 && newSpeed <= 15) {
                    ships[0].speed = newSpeed;
                    updateAllShipPositions();
                }
            });
            
            otherSpeedInput.addEventListener('input', function(e) {
                const newSpeed = parseFloat(e.target.value);
                if (newSpeed >= 1 && newSpeed <= 15) {
                    ships[1].speed = newSpeed;
                    updateAllShipPositions();
                }
            });
            
            timeSlider.addEventListener('input', function(e) {
                currentTime = parseInt(e.target.value);
                updateAllShipPositions();
                // Sync floating time slider
                if (floatingTimeControl) {
                    floatingTimeControl.value = currentTime;
                    updateFloatingTimeDisplay();
                }
                // Sync vertical time slider
                if (verticalTimeControl) {
                    verticalTimeControl.value = currentTime;
                    updateVerticalTimeDisplay();
                }
            });
            
            // Setup floating time slider
            if (floatingTimeControl) {
                floatingTimeControl.addEventListener('input', function(e) {
                    currentTime = parseInt(e.target.value);
                    updateAllShipPositions();
                    // Sync main time slider
                    if (timeSlider) {
                        timeSlider.value = currentTime;
                    }
                    // Sync vertical time slider
                    if (verticalTimeControl) {
                        verticalTimeControl.value = currentTime;
                        updateVerticalTimeDisplay();
                    }
                    updateFloatingTimeDisplay();
                    resetFloatingSliderAutoHide();
                });
                
                floatingTimeControl.addEventListener('touchstart', function() {
                    showFloatingTimeSlider();
                });
            }
            
            // Setup vertical time slider
            if (verticalTimeControl) {
                verticalTimeControl.addEventListener('input', function(e) {
                    currentTime = parseInt(e.target.value);
                    updateAllShipPositions();
                    // Sync other time sliders
                    if (timeSlider) {
                        timeSlider.value = currentTime;
                    }
                    if (floatingTimeControl) {
                        floatingTimeControl.value = currentTime;
                        updateFloatingTimeDisplay();
                    }
                    updateVerticalTimeDisplay();
                    updateHeaderTimeDisplay();
                });
            }
        }
        
        // Update all ship positions
        function updateAllShipPositions() {
            ships.forEach(ship => {
                updateShipPosition(ship);
            });
            
            // Update meeting warning and single meeting point
            updateMeetingWarning();
            updateSingleMeetingPoint();
            
            // Update dynamic meeting point marker
            updateDynamicMeetingPoint();
            
            // Update time display
            document.getElementById('positionTime').textContent = 
                currentTime === 0 ? 'Now' : `+${currentTime} min`;
            
            // Update floating time display
            updateFloatingTimeDisplay();
            
            // Update header time display
            updateHeaderTimeDisplay();
            
            // Update vertical time display
            updateVerticalTimeDisplay();
        }
        
        // ===== HEADER TIME SLIDER MANAGEMENT =====
        
        function showHeaderTimeSlider() {
            const headerSlider = document.getElementById('headerTimeSlider');
            const mapTitle = document.getElementById('mapTitle');
            
            if (headerSlider && mapTitle) {
                headerSlider.classList.add('active');
                mapTitle.classList.add('hidden');
            }
        }
        
        function hideHeaderTimeSlider() {
            const headerSlider = document.getElementById('headerTimeSlider');
            const mapTitle = document.getElementById('mapTitle');
            
            if (headerSlider && mapTitle) {
                headerSlider.classList.remove('active');
                mapTitle.classList.remove('hidden');
            }
        }
        
        function updateHeaderTimeDisplay() {
            const headerTimeInfo = document.getElementById('headerTimeInfo');
            if (headerTimeInfo) {
                headerTimeInfo.textContent = currentTime === 0 ? 'Now' : `+${currentTime} min`;
            }
        }
        
        // ===== VERTICAL TIME SLIDER MANAGEMENT =====
        
        function showVerticalTimeSlider() {
            const verticalSlider = document.getElementById('verticalTimeSlider');
            if (verticalSlider) {
                verticalSlider.classList.add('active');
                verticalSliderActive = true;
                console.log('Vertical time slider activated');
            }
        }
        
        function hideVerticalTimeSlider() {
            const verticalSlider = document.getElementById('verticalTimeSlider');
            if (verticalSlider) {
                verticalSlider.classList.remove('active');
                verticalSliderActive = false;
                console.log('Vertical time slider deactivated');
            }
        }
        
        function updateVerticalTimeDisplay() {
            const verticalTimeInfo = document.getElementById('verticalTimeInfo');
            if (verticalTimeInfo) {
                verticalTimeInfo.textContent = currentTime === 0 ? 'Now' : `+${currentTime} min`;
            }
        }
        
        function setupHeaderTimeSlider() {
            const headerTimeControl = document.getElementById('headerTimeControl');
            
            if (headerTimeControl) {
                headerTimeControl.addEventListener('input', function(e) {
                    currentTime = parseInt(e.target.value);
                    updateAllShipPositions();
                    
                    // Sync with other time controls
                    const timeSlider = document.getElementById('timeSlider');
                    const mobileTimeSlider = document.getElementById('mobileTimeSlider');
                    const floatingTimeControl = document.getElementById('floatingTimeControl');
                    
                    if (timeSlider) timeSlider.value = currentTime;
                    if (mobileTimeSlider) mobileTimeSlider.value = currentTime;
                    if (floatingTimeControl) floatingTimeControl.value = currentTime;
                    
                    updateHeaderTimeDisplay();
                    updateFloatingTimeDisplay();
                });
            }
        }
        
        // ===== FLOATING TIME SLIDER MANAGEMENT =====
        
        let floatingSliderTimeout = null;
        
        function showFloatingTimeSlider() {
            const floatingSlider = document.getElementById('floatingTimeSlider');
            if (floatingSlider && shipSimulationActive) {
                floatingSlider.classList.add('active');
                resetFloatingSliderAutoHide();
            }
        }
        
        function hideFloatingTimeSlider() {
            const floatingSlider = document.getElementById('floatingTimeSlider');
            if (floatingSlider) {
                floatingSlider.classList.remove('active');
            }
        }
        
        function updateFloatingTimeDisplay() {
            const floatingTimeInfo = document.getElementById('floatingTimeInfo');
            if (floatingTimeInfo) {
                floatingTimeInfo.textContent = currentTime === 0 ? 'Now' : `+${currentTime} min`;
            }
        }
        
        function resetFloatingSliderAutoHide() {
            if (floatingSliderTimeout) {
                clearTimeout(floatingSliderTimeout);
            }
            floatingSliderTimeout = setTimeout(() => {
                const floatingSlider = document.getElementById('floatingTimeSlider');
                if (floatingSlider && !mobileBottomSheetExpanded) {
                    floatingSlider.classList.add('auto-hide');
                    setTimeout(() => {
                        floatingSlider.classList.remove('active', 'auto-hide');
                    }, 3000);
                }
            }, 3000);
        }
        
        // Auto-minimize control panel after ship configuration
        function autoMinimizeAfterConfiguration() {
            console.log('Auto-minimizing control panel after configuration...');
            collapseBottomSheet();
            showFloatingTimeSlider();
        }
        
        // Update ship position based on current time and speed for a specific ship
        function updateShipPosition(ship) {
            if (!ship.marker) {
                console.warn(`Cannot update ${ship.name} position: missing marker`);
                return;
            }
            
            const shipData = getShipPositionAtTime(ship, currentTime);
            
            // Validate position data
            if (!shipData.position || shipData.position.length !== 2) {
                console.error(`Invalid ${ship.name} position data:`, shipData);
                return;
            }
            
            // Validate coordinates
            const [lat, lng] = shipData.position;
            if (isNaN(lat) || isNaN(lng)) {
                console.error(`Invalid ${ship.name} coordinates:`, lat, lng);
                return;
            }
            
            try {
                ship.marker.setLatLng(shipData.position);
                
                // Update rotation with new marker structure
                const element = ship.marker.getElement();
                if (element && !isNaN(shipData.bearing)) {
                    const shipDiv = element.querySelector('.ship-marker');
                    if (shipDiv) {
                        shipDiv.style.transform = `rotate(${shipData.bearing}deg)`;
                    }
                }
                
                // Update popup content
                const popupContent = `
                    <div style="font-family: 'Courier New', monospace; font-size: 12px;">
                        <strong>‚öì ${ship.name}</strong><br>
                        <em>Route Simulation</em><br>
                        <hr style="margin: 5px 0;">
                        üìç <strong>Lat:</strong> ${lat.toFixed(5)}¬∞<br>
                        üìç <strong>Lng:</strong> ${lng.toFixed(5)}¬∞<br>
                        üß≠ <strong>Heading:</strong> ${shipData.bearing.toFixed(0)}¬∞<br>
                        üö¢ <strong>Status:</strong> In Transit<br>
                        üé® <strong>Color:</strong> ${ship.color}
                    </div>
                `;
                ship.marker.setPopupContent(popupContent);
                
            } catch (error) {
                console.error(`Error updating ${ship.name} position:`, error);
            }
        }
        
        // Select ship direction for individual ships
        function selectShipDirection(shipId, direction) {
            const ship = ships.find(s => s.id === shipId);
            if (!ship || direction === ship.direction) return;
            
            ship.direction = direction;
            
            // Update UI for the specific ship - both desktop and mobile
            document.getElementById(`${shipId}Northbound`).classList.toggle('selected', direction === 'northbound');
            document.getElementById(`${shipId}Southbound`).classList.toggle('selected', direction === 'southbound');
            
            // Update mobile UI as well
            const mobileNorthbound = document.getElementById(`mobile${shipId.charAt(0).toUpperCase() + shipId.slice(1)}Northbound`);
            const mobileSouthbound = document.getElementById(`mobile${shipId.charAt(0).toUpperCase() + shipId.slice(1)}Southbound`);
            if (mobileNorthbound) mobileNorthbound.classList.toggle('selected', direction === 'northbound');
            if (mobileSouthbound) mobileSouthbound.classList.toggle('selected', direction === 'southbound');
            
            // If ship simulation is active, reinitialize with new direction
            if (shipSimulationActive && ship.marker) {
                // Reset time to 0 and clear custom start position for this ship
                ship.customStartPosition = null;
                ship.customStartTime = 0;
                
                // Don't reset global time - other ship should continue
                
                // Get the new starting position for this ship
                const initialData = getShipPositionAtTime(ship, currentTime);
                ship.marker.setLatLng(initialData.position);
                
                console.log(`${ship.name} direction changed to ${direction}, ship repositioned to: [${initialData.position[0].toFixed(5)}, ${initialData.position[1].toFixed(5)}]`);
                
                // Update rotation
                const element = ship.marker.getElement();
                if (element) {
                    const shipDiv = element.querySelector('.ship-marker');
                    if (shipDiv) {
                        shipDiv.style.transform = `rotate(${initialData.bearing}deg)`;
                    }
                }
                
                // Update meeting points and warnings
                updateSingleMeetingPoint();
                updateDynamicMeetingPoint();
                updateMeetingWarning();
                
                // Manual control only - no auto-minimize
            }
        }
        
        // ===== MOBILE INTERACTION ENHANCEMENTS =====
        
        // Mobile state variables
        let mobileBottomSheetExpanded = false;
        let hamburgerMenuOpen = false;
        let activeTab = 'ownShip';
        
        // Bottom sheet drag handler
        function setupBottomSheetDrag() {
            const dragHandle = document.getElementById('bottomSheetDragHandle');
            const bottomSheet = document.getElementById('shipControlPanel');
            
            if (!dragHandle || !bottomSheet) return;
            
            let startY = 0;
            let startTime = 0;
            
            dragHandle.addEventListener('touchstart', function(e) {
                startY = e.touches[0].clientY;
                startTime = Date.now();
                dragHandle.classList.add('dragging');
                bottomSheet.style.transition = 'none';
            }, { passive: false });
            
            dragHandle.addEventListener('touchend', function(e) {
                const endTime = Date.now();
                const currentY = e.changedTouches[0].clientY;
                const deltaY = currentY - startY;
                
                dragHandle.classList.remove('dragging');
                bottomSheet.style.transition = 'transform 0.3s ease-out';
                
                // Toggle based on swipe direction
                if (Math.abs(deltaY) > 50) {
                    if (deltaY > 0) {
                        collapseBottomSheet();
                    } else {
                        expandBottomSheet();
                    }
                } else {
                    // Tap to toggle
                    if (mobileBottomSheetExpanded) {
                        collapseBottomSheet();
                    } else {
                        expandBottomSheet();
                    }
                }
                
                startY = 0;
            }, { passive: false });
        }
        
        // Bottom sheet state management
        function expandBottomSheet() {
            const bottomSheet = document.getElementById('shipControlPanel');
            if (bottomSheet) {
                bottomSheet.classList.add('expanded');
                bottomSheet.classList.remove('collapsed');
                mobileBottomSheetExpanded = true;
            }
        }
        
        function collapseBottomSheet() {
            const bottomSheet = document.getElementById('shipControlPanel');
            if (bottomSheet) {
                bottomSheet.classList.remove('expanded');
                bottomSheet.classList.add('collapsed');
                mobileBottomSheetExpanded = false;
            }
        }
        
        // Mobile tab switching
        function switchMobileTab(tabName) {
            activeTab = tabName;
            
            // Update tab buttons
            document.querySelectorAll('.mobile-tab-button').forEach(button => {
                button.classList.remove('active');
            });
            document.querySelector(`.mobile-tab-button[onclick="switchMobileTab('${tabName}')"]`).classList.add('active');
            
            // Update tab panels
            document.querySelectorAll('.mobile-tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.getElementById(`${tabName}Panel`).classList.add('active');
        }
        
        // Hamburger menu toggle
        function toggleHamburgerMenu() {
            const dropdown = document.getElementById('hamburgerDropdown');
            const button = document.querySelector('.hamburger-button');
            
            if (hamburgerMenuOpen) {
                dropdown.classList.remove('show');
                button.innerHTML = '‚ò∞';
                hamburgerMenuOpen = false;
            } else {
                dropdown.classList.add('show');
                button.innerHTML = '√ó';
                hamburgerMenuOpen = true;
            }
        }
        
        // Initialize mobile interactions - Mobile-only optimized
        function initializeMobileInteractions() {
            setupBottomSheetDrag();
            
            // Setup mobile input synchronization
            const mobileOwnSpeed = document.getElementById('mobileOwnShipSpeed');
            const mobileOtherSpeed = document.getElementById('mobileOtherShipSpeed');
            const mobileTimeSlider = document.getElementById('mobileTimeSlider');
            
            if (mobileOwnSpeed) {
                mobileOwnSpeed.addEventListener('input', function(e) {
                    const newSpeed = parseFloat(e.target.value);
                    document.getElementById('ownShipSpeed').value = newSpeed;
                    if (newSpeed >= 1 && newSpeed <= 15) {
                        ships[0].speed = newSpeed;
                        updateAllShipPositions();
                        // Manual control only - no auto-minimize
                    }
                });
            }
            
            if (mobileOtherSpeed) {
                mobileOtherSpeed.addEventListener('input', function(e) {
                    const newSpeed = parseFloat(e.target.value);
                    document.getElementById('otherShipSpeed').value = newSpeed;
                    if (newSpeed >= 1 && newSpeed <= 15) {
                        ships[1].speed = newSpeed;
                        updateAllShipPositions();
                        // Manual control only - no auto-minimize
                    }
                });
            }
            
            if (mobileTimeSlider) {
                mobileTimeSlider.addEventListener('input', function(e) {
                    const newTime = parseInt(e.target.value);
                    document.getElementById('timeSlider').value = newTime;
                    currentTime = newTime;
                    updateAllShipPositions();
                    
                    // Sync vertical time slider
                    const verticalTimeControl = document.getElementById('verticalTimeControl');
                    if (verticalTimeControl) {
                        verticalTimeControl.value = newTime;
                        updateVerticalTimeDisplay();
                    }
                });
            }
            
            // Mobile opacity slider
            const mobileOpacitySlider = document.getElementById('mobileOpacitySlider');
            if (mobileOpacitySlider) {
                mobileOpacitySlider.addEventListener('input', function(e) {
                    const opacity = e.target.value / 100;
                    document.getElementById('mobileOpacityValue').textContent = e.target.value;
                    
                    if (opacity === 0) {
                        if (map.hasLayer(openSeaMapOverlay)) {
                            map.removeLayer(openSeaMapOverlay);
                        }
                    } else {
                        openSeaMapOverlay.setOpacity(opacity);
                        if (!map.hasLayer(openSeaMapOverlay)) {
                            openSeaMapOverlay.addTo(map);
                        }
                    }
                });
            }
            
            // Dark mode toggle
            const mobileDarkModeToggle = document.getElementById('mobileDarkModeToggle');
            if (mobileDarkModeToggle) {
                mobileDarkModeToggle.addEventListener('change', function(e) {
                    if (e.target.checked) {
                        // Enable dark mode
                        document.body.style.backgroundColor = '#1a1a2e';
                        document.getElementById('map').style.filter = 'invert(1) hue-rotate(180deg)';
                    } else {
                        // Disable dark mode
                        document.body.style.backgroundColor = '#1a1a2e';
                        document.getElementById('map').style.filter = 'none';
                    }
                });
            }
            
            // Coordinates toggle
            const mobileCoordinatesToggle = document.getElementById('mobileCoordinatesToggle');
            if (mobileCoordinatesToggle) {
                mobileCoordinatesToggle.addEventListener('change', function(e) {
                    const coordinatesDisplay = document.getElementById('mobileCoordinatesDisplay');
                    if (coordinatesDisplay) {
                        coordinatesDisplay.style.display = e.target.checked ? 'block' : 'none';
                    }
                });
            }
        }
        
        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', initializeMobileInteractions);
        
        // Close hamburger menu when clicking outside
        document.addEventListener('click', function(e) {
            const hamburgerMenu = document.querySelector('.mobile-hamburger-menu');
            if (hamburgerMenu && !hamburgerMenu.contains(e.target) && hamburgerMenuOpen) {
                toggleHamburgerMenu();
            }
        });
        
        // ===== MOBILE PERFORMANCE OPTIMIZATIONS =====
        
        // Throttle function for performance optimization
        function throttle(func, limit) {
            let inThrottle;
            return function() {
                const args = arguments;
                const context = this;
                if (!inThrottle) {
                    func.apply(context, args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            }
        }
        
        // Optimized ship position updates for mobile (30fps)
        const throttledUpdateAllShipPositions = throttle(updateAllShipPositions, 33);
        
        // Optimized coordinate display updates
        const throttledCoordinateUpdate = throttle(function(e) {
            const lat = e.latlng.lat.toFixed(5);
            const lng = e.latlng.lng.toFixed(5);
            
            const coordinateDisplay = document.getElementById('coordinates');
            if (coordinateDisplay) {
                coordinateDisplay.innerHTML = `Lat: ${lat} Lng: ${lng}`;
            }
            
            const mobileCoordinatesDisplay = document.getElementById('mobileCoordinatesDisplay');
            if (mobileCoordinatesDisplay && mobileCoordinatesDisplay.style.display !== 'none') {
                mobileCoordinatesDisplay.innerHTML = `Lat: ${lat} Lng: ${lng}`;
            }
        }, 100);
        
        // Memory cleanup for mobile - optimized for single meeting marker
        function optimizeMemoryUsage() {
            // Single meeting marker doesn't require cleanup as it's replaced, not accumulated
            // Keep this function for future optimization needs
            console.log('Memory optimization - single meeting marker system active');
        }
        
        // Initialize performance optimizations - Mobile-only
        function initializePerformanceOptimizations() {
            // Replace coordinate update with throttled version
            map.off('mousemove');
            map.on('mousemove', throttledCoordinateUpdate);
            
            // Optimize map settings for mobile
            map.options.inertia = false;
            map.options.zoomSnap = 1;
            
            // Memory cleanup interval
            setInterval(optimizeMemoryUsage, 30000);
            
            console.log('Mobile performance optimizations applied');
        }
        
        // Initialize after DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(initializePerformanceOptimizations, 500);
        });
    </script>
</body>
</html>