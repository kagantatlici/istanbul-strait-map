<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Professional nautical chart of Istanbul Strait (Bosphorus) using NOAA Chart Display Service for clean display">
    <meta name="keywords" content="Istanbul Strait, Bosphorus, nautical chart, NOAA charts, maritime navigation, clean display">
    <title>Istanbul Strait Nautical Map - V3</title>
    
    <!-- Preload critical resources for faster loading -->
    <link rel="preconnect" href="https://unpkg.com">
    <link rel="preconnect" href="https://basemaps.cartocdn.com">
    <link rel="preconnect" href="https://gis.charttools.noaa.gov">
    <link rel="preconnect" href="https://tiles.openseamap.org">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
          crossorigin="" />
    
    <style>
        /* ===== MOBILE-FIRST CSS FOUNDATION ===== */
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a2e;
            overflow: hidden;
            /* Mobile-first responsive setup */
            display: flex;
            flex-direction: column;
            height: 100vh;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Optimize for mobile touch */
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* ===== MOBILE-ONLY STYLES ===== */
        
        #map {
            height: 100vh;
            width: 100vw;
            background-color: #f0f8ff;
            flex: 1;
            position: relative;
            touch-action: manipulation;
        }
        
        .leaflet-container {
            background-color: #f0f8ff;
            font-family: 'Courier New', monospace;
        }
        
        /* Hide Leaflet attribution for cleaner look */
        .leaflet-control-attribution {
            display: none;
        }
        
        /* Hide Leaflet zoom controls - rely on pinch-to-zoom only */
        .leaflet-control-zoom {
            display: none !important;
        }
        
        /* (removed) header-time-slider: unused */

        /* ===== GPS Switch Panel (under vertical time bar) ===== */
        .gps-switch-panel {
            /* Anchor to bottom-right: stay above ship toggle with 12px gap */
            position: fixed;
            right: 8px;
            /* 90px (toggle bottom) + 50px (toggle size) + 12px gap */
            bottom: calc(90px + 50px + 12px + env(safe-area-inset-bottom, 0px));
            z-index: 1301;
            display: none; /* visible when simulation active */
            align-items: center;
            flex-direction: column; /* label under the switch */
            gap: 4px;
            padding: 6px 10px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 50, 100, 0.9));
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            user-select: none;
        }
        .gps-switch-label { font-size: 11px; opacity: 0.9; }
        
        /* (removed) header-time-slider subrules: unused */
        
        
        /* Ship Toggle Button */
        .ship-toggle {
            position: absolute;
            bottom: 90px;
            right: 15px;
            z-index: 1000;
            background: linear-gradient(135deg, rgba(33, 150, 243, 0.95), rgba(21, 101, 192, 0.95));
            color: white;
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .ship-toggle:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
        }
        
        .ship-toggle.active {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.95), rgba(56, 142, 60, 0.95));
            border-color: rgba(139, 195, 74, 0.5);
            animation: pulse-green 2s infinite;
        }
        
        @keyframes pulse-green {
            0% { box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); }
            50% { box-shadow: 0 4px 20px rgba(76, 175, 80, 0.6); }
            100% { box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); }
        }
        
        /* V3 Enhanced Hamburger Menu Styles */
        .mobile-hamburger-menu {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1001;
        }
        
        .hamburger-button {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 50, 100, 0.9));
            color: white;
            border: none;
            border-radius: 8px;
            width: 50px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .hamburger-button:active {
            transform: scale(0.95);
            background: linear-gradient(135deg, rgba(0, 30, 60, 0.95), rgba(0, 20, 40, 0.95));
        }
        
        /* V3 Compact Dropdown with Ship Controls */
        .hamburger-dropdown {
            position: absolute;
            top: 50px;
            right: 0;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(0, 30, 60, 0.95));
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
            min-width: 280px;
            max-width: 320px;
            max-height: 70vh;
            overflow-y: auto;
            transform: translateY(-10px);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 1002;
        }
        
        .hamburger-dropdown.show {
            transform: translateY(0);
            opacity: 1;
            visibility: visible;
        }
        
        .hamburger-dropdown::before {
            content: '';
            position: absolute;
            top: -8px;
            right: 20px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid rgba(255, 255, 255, 0.3);
        }
        
        /* V3 Ship Controls in Dropdown */
        .ship-controls-section {
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .ship-controls-header {
            text-align: center;
            color: #FFD700;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
        }
        
        .ship-control-group {
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .ship-control-group.own-ship {
            background: rgba(33, 150, 243, 0.1);
            border-color: rgba(33, 150, 243, 0.3);
        }
        
        .ship-control-group.other-ship {
            background: rgba(255, 152, 0, 0.1);
            border-color: rgba(255, 152, 0, 0.3);
        }
        
        .ship-control-title {
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 6px;
            text-align: center;
        }
        
        .ship-control-title.own-ship {
            color: #2196F3;
        }
        
        .ship-control-title.other-ship {
            color: #FF9800;
        }
        
        .direction-controls {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
        }
        
        .direction-btn {
            flex: 1;
            padding: 6px 2px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: white;
            font-size: 9px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
            height: 28px;
            line-height: 16px;
        }
        
        .direction-btn.selected {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.6);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .speed-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.8);
            min-width: 40px;
        }
        
        .speed-input {
            flex: 1;
            padding: 4px 6px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: white;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            text-align: center;
            height: 28px;
        }
        
        .speed-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.15);
        }
        
        /* Other Controls Section */
        .other-controls-section {
            padding: 15px;
        }
        
        .hamburger-item {
            margin-bottom: 15px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .hamburger-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        .hamburger-item-title {
            font-size: 12px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 8px;
            font-family: 'Courier New', monospace;
        }
        
        .hamburger-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .mobile-toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }
        
        .mobile-toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .mobile-toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.3);
            transition: .4s;
            border-radius: 20px;
        }
        
        .mobile-toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .mobile-toggle-slider {
            background-color: #2196F3;
        }
        
        input:checked + .mobile-toggle-slider:before {
            transform: translateX(20px);
        }
        
        .hamburger-slider-container {
            margin-top: 8px;
        }
        
        .hamburger-slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .hamburger-slider {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }
        
        .hamburger-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #2196F3;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .hamburger-value-display {
            text-align: center;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 4px;
        }
        
        /* Vertical Time Slider - Transparent Right Side */
        .vertical-time-slider {
            position: absolute;
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 999;
            background: transparent; /* Fully transparent background */
            padding: 10px 5px;
            border-radius: 10px;
            height: 300px;
            width: 50px; /* slightly wider for easier handling */
            display: none;
            font-family: 'Courier New', monospace;
        }
        
        .vertical-time-slider.active {
            display: block;
        }
        
        .vertical-time-labels {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.9);
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            margin-bottom: 8px;
        }
        
        .vertical-time-labels span {
            margin-bottom: 15px;
            writing-mode: horizontal-tb;
        }
        
        .vertical-slider-container {
            height: 240px; /* taller for more travel */
            display: flex;
            justify-content: center;
            margin-bottom: 8px;
        }
        
        .vertical-slider-container input[type="range"] {
            width: 240px; /* match container height due to rotation */
            height: 8px; /* thicker track for visibility */
            background: rgba(255, 255, 255, 0.4);
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
            transform: rotate(-90deg);
            transform-origin: center center;
        }
        
        .vertical-slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px; /* larger thumb */
            height: 22px; /* larger thumb */
            background: #2196F3;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid #ffffff;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
        }
        
        .vertical-slider-container input[type="range"]::-moz-range-thumb {
            width: 22px; /* larger thumb */
            height: 22px; /* larger thumb */
            background: #2196F3;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid #ffffff;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
        }
        
        .vertical-time-info {
            text-align: center;
            font-size: 9px;
            font-weight: bold;
            color: #00E676; /* brighter green for readability */
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }
        
        /* Responsive Design */
        @media (min-width: 768px) {
            .hamburger-dropdown {
                min-width: 320px;
            }
            
            .ship-control-group {
                padding: 15px;
            }
            
            .ship-control-title {
                font-size: 13px;
            }
            
            .speed-input {
                font-size: 13px;
                padding: 8px 10px;
            }
            
            .direction-btn {
                padding: 10px 6px;
                font-size: 11px;
            }
        }
    /* ===== Custom Ship Marker Styles ===== */
        .ship-marker-custom {
            background: transparent !important;
            border: none !important;
        }
        .ship-marker {
            width: 30px; /* Scaled down from 44px */
            height: 30px; /* Scaled down from 44px */
            background: white;
            border-radius: 50%;
            cursor: pointer;
            transform-origin: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            position: relative;
            transition: transform 0.2s ease;
        }
        .ship-marker.own-ship {
            border: 2px solid #2196F3;
        }
        .ship-marker.other-ship {
            border: 2px solid #FF9800;
        }
        .ship-marker::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-left: 6px solid transparent; /* Scaled down */
            border-right: 6px solid transparent; /* Scaled down */
            transform: translate(-50%, -70%); /* Adjusted for new size */
        }
        .ship-marker.own-ship::before {
            border-bottom: 12px solid #2196F3; /* Scaled down */
        }
        .ship-marker.other-ship::before {
            border-bottom: 12px solid #FF9800; /* Scaled down */
        }

        /* Advisory banners */
        .advisory-banners {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1200;
            display: flex;
            flex-direction: column;
            gap: 6px;
            max-width: calc(100vw - 80px);
        }
        .banner {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 6px 10px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.2);
            color: #fff;
            text-align: center;
            backdrop-filter: blur(2px);
        }
        .banner-status.success { background: rgba(56, 142, 60, 0.95); }
        .banner-status.error { background: rgba(198, 40, 40, 0.95); }
        .banner-status.info { background: rgba(120, 144, 156, 0.85); }
        .banner-minspeed.info { background: rgba(25, 118, 210, 0.95); }
        .banner-distance { background: rgba(76, 175, 80, 0.95); }

        /* Waypoint label for route overlay (compact) */
        .route-waypoint {
            background: transparent;
            border: none;
            border-radius: 0;
            display: inline-flex;
            align-items: center;
            gap: 3px;
            pointer-events: none;
        }
        .route-wp-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.35);
            box-shadow: 0 0 0 1px rgba(255,255,255,0.45);
            opacity: 0.85;
        }
        .route-wp-num {
            font-size: 9px;
            font-weight: 700;
            color: rgba(255,255,255,0.75);
            text-shadow: 0 1px 2px rgba(0,0,0,0.6);
        }

        /* ===== Custom Meeting Point Marker Style ===== */
        /* (removed) custom-meeting-marker: unused */
        @keyframes meetingPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); box-shadow: 0 2px 12px rgba(255, 0, 0, 0.8); }
            100% { transform: scale(1); }
        }

        /* ===== Meeting Point Marker Styles (from working version) ===== */
        .meeting-point-marker {
            width: 24px;
            height: 24px;
            background: radial-gradient(circle, #ff0000, #cc0000);
            border: 3px solid #ffffff;
            border-radius: 50%;
            position: relative;
            animation: meetingPulse 2s infinite;
            box-shadow: 0 2px 8px rgba(255, 0, 0, 0.5);
        }
        .meeting-point-marker::before {
            content: '‚ö†';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        /* (removed) single-meeting-marker: unused */
        @keyframes meetingRipple {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        /* ===== Dark Mode: Low-Glow, Night-Friendly Palette ===== */
        body.dark-mode { background-color: #0b0f12; color: #cfd8dc; }
        body.dark-mode .leaflet-container { background-color: #0b0f12; }
        
        /* Panels and controls */
        /* (removed) dark-mode header-time-slider overrides */

        body.dark-mode .hamburger-button{ background: rgba(20,24,28,0.95); border: 1px solid rgba(255,255,255,0.08); box-shadow: none; }
        body.dark-mode .hamburger-dropdown{ background: rgba(12,14,18,0.98); border: 1px solid rgba(255,255,255,0.08); box-shadow: none; }
        body.dark-mode .hamburger-dropdown::before{ border-bottom-color: rgba(255,255,255,0.08); }
        body.dark-mode .ship-controls-header{ color: #b0bec5; }
        body.dark-mode .ship-control-group{ background: rgba(255,255,255,0.03); border-color: rgba(255,255,255,0.08); }
        body.dark-mode .ship-control-group.own-ship{ background: rgba(120,144,156,0.08); border-color: rgba(120,144,156,0.18); }
        body.dark-mode .ship-control-group.other-ship{ background: rgba(255,152,0,0.05); border-color: rgba(255,152,0,0.16); }
        body.dark-mode .direction-btn{ background: rgba(255,255,255,0.06); border-color: rgba(255,255,255,0.16); }
        body.dark-mode .direction-btn.selected{ background: rgba(255,255,255,0.18); border-color: rgba(255,255,255,0.28); box-shadow: none; }
        body.dark-mode .speed-input{ background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.18); }
        /* Dark mode: tone down toggle switch blue */
        body.dark-mode input:checked + .mobile-toggle-slider { background-color: rgba(76, 118, 170, 0.8); }
        body.dark-mode .mobile-toggle-slider { background-color: rgba(255,255,255,0.18); }
        body.dark-mode .mobile-toggle-slider:before { background-color: #b0bec5; }

        /* Ship toggle */
        body.dark-mode .ship-toggle{ background: rgba(26,32,44,0.9); border: 1px solid rgba(255,255,255,0.08); box-shadow: none; }
        body.dark-mode .ship-toggle.active{ animation: none; border-color: rgba(139,195,74,0.25); }

        /* Banners */
        body.dark-mode .banner{ box-shadow: none; border: 1px solid rgba(255,255,255,0.12); color: #f2f2f2; background: rgba(16,20,24,0.94); }
        body.dark-mode .banner-distance{ background: rgba(76,175,80,0.60); }
        body.dark-mode .banner-minspeed.info{ background: rgba(25,118,210,0.60); }
        body.dark-mode .banner-status.success{ background: rgba(56,142,60,0.60); }
        body.dark-mode .banner-status.error{ background: rgba(198,40,40,0.60); }
        body.dark-mode .banner-status.info{ background: rgba(120,144,156,0.50); }

        /* Route waypoint labels */
        body.dark-mode .route-wp-dot{ box-shadow: none; border: 1px solid rgba(255,255,255,0.12); opacity: 0.75; }
        body.dark-mode .route-wp-num{ color: rgba(255,255,255,0.7); text-shadow: none; }

        /* Ship markers */
        body.dark-mode .ship-marker{ background: rgba(255,255,255,0.06); box-shadow: none; }
        body.dark-mode .ship-marker.own-ship{ border-color: rgba(33,150,243,0.6); }
        body.dark-mode .ship-marker.other-ship{ border-color: rgba(255,152,0,0.6); }
        body.dark-mode .ship-marker.own-ship::before{ border-bottom-color: rgba(33,150,243,0.6); }
        body.dark-mode .ship-marker.other-ship::before{ border-bottom-color: rgba(255,152,0,0.6); }

        /* Meeting markers - no glow, subdued */
        body.dark-mode .meeting-point-marker{
            animation: none !important;
            box-shadow: none !important;
            background: #a33b3b !important;
            border-color: rgba(255,255,255,0.12) !important;
        }
        body.dark-mode .meeting-point-marker::before{
            color: #f0f0f0;
        }

        /* HUD */
        body.dark-mode .mini-hud{ background: rgba(10,12,14,0.65); border: 1px solid rgba(255,255,255,0.10); }

        
    </style>
</head>

    <body>
    <!-- Advisory Banners (top-center) -->
    <div id="advisoryBanners" class="advisory-banners" style="display:none;">
        <div id="bannerStatus" class="banner banner-status" style="display:none;"></div>
        <div id="bannerDistance" class="banner banner-distance"></div>
        <div id="bannerMinSpeed" class="banner banner-minspeed"></div>
    </div>
    
    <!-- GPS Switch Panel (under vertical time bar) -->
    <div id="gpsSnapPanel" class="gps-switch-panel" title="GPS ile rotaya hizala">
        <label class="mobile-toggle-switch" aria-label="GPS">
            <input type="checkbox" id="gpsSnapSwitch">
            <span class="mobile-toggle-slider"></span>
        </label>
        <span class="gps-switch-label">GPS</span>
    </div>
    <!-- V3 Hamburger Menu with Ship Data -->
    <div class="mobile-hamburger-menu">
        <div class="hamburger-button" onclick="toggleHamburgerMenu()">
            ‚ò∞
        </div>
        <div class="hamburger-dropdown" id="hamburgerDropdown">
            <!-- Ship Data Section -->
            <div class="ship-controls-section">
                <div class="ship-controls-header">‚öì Ship Data</div>
                
                <!-- Own Ship Controls -->
                <div class="ship-control-group own-ship">
                    <div class="ship-control-title own-ship">üö¢ Own Ship (Blue)</div>
                    <div class="direction-controls">
                        <div class="direction-btn selected" id="ownNorthbound" onclick="selectShipDirection('own', 'northbound')">
                            ‚¨ÜÔ∏è North
                        </div>
                        <div class="direction-btn" id="ownSouthbound" onclick="selectShipDirection('own', 'southbound')">
                            ‚¨áÔ∏è South
                        </div>
                    </div>
                    <div class="speed-control">
                        <label class="speed-label">Speed:</label>
                        <input type="number" class="speed-input" id="ownShipSpeed" min="1" max="15" value="11" step="0.5">
                        <span style="font-size: 10px; color: rgba(255,255,255,0.6);">kts</span>
                    </div>
                    <div class="speed-control" style="margin-top:8px;">
                        <label class="speed-label">Route:</label>
                        <select class="speed-input" id="ownRouteSelect" style="text-align:left;">
                            <option value="orta">Orta Kanal</option>
                            <option value="sancak">Sancak Hat</option>
                            <option value="iskele">ƒ∞skele Hat</option>
                        </select>
                    </div>
                </div>
                
                <!-- Other Ship Controls -->
                <div class="ship-control-group other-ship">
                    <div class="ship-control-title other-ship">üö¢ Other Ship (Orange)</div>
                    <div class="direction-controls">
                        <div class="direction-btn selected" id="otherNorthbound" onclick="selectShipDirection('other', 'northbound')">
                            ‚¨ÜÔ∏è North
                        </div>
                        <div class="direction-btn" id="otherSouthbound" onclick="selectShipDirection('other', 'southbound')">
                            ‚¨áÔ∏è South
                        </div>
                    </div>
                    <div class="speed-control">
                        <label class="speed-label">Speed:</label>
                        <input type="number" class="speed-input" id="otherShipSpeed" min="1" max="15" value="7.5" step="0.5">
                        <span style="font-size: 10px; color: rgba(255,255,255,0.6);">kts</span>
                    </div>
                    <div class="speed-control" style="margin-top:8px;">
                        <label class="speed-label">Route:</label>
                        <select class="speed-input" id="otherRouteSelect" style="text-align:left;">
                            <option value="orta">Orta Kanal</option>
                            <option value="sancak">Sancak Hat</option>
                            <option value="iskele">ƒ∞skele Hat</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <!-- Other Controls Section -->
            <div class="other-controls-section">
                <!-- Akƒ±ntƒ± etkisi -->
                <div class="hamburger-item">
                    <div class="hamburger-toggle">
                        <span class="hamburger-item-title">üåä Akƒ±ntƒ± etkisi:</span>
                        <label class="mobile-toggle-switch">
                            <input type="checkbox" id="mobileCurrentAdvantageToggle" checked>
                            <span class="mobile-toggle-slider"></span>
                        </label>
                    </div>
                    <div id="mobileCurrentAdvantageDisplay" style="font-size: 11px; opacity: 0.8; margin-top: 5px;">
                        Akƒ±ntƒ± etkisi aktif
                    </div>
                </div>

                <!-- Show/Hide Route -->
                <div class="hamburger-item">
                    <div class="hamburger-toggle">
                        <span class="hamburger-item-title">üó∫Ô∏è Show/Hide Route:</span>
                        <label class="mobile-toggle-switch">
                            <input type="checkbox" id="mobileRoutesToggle" checked>
                            <span class="mobile-toggle-slider"></span>
                        </label>
                    </div>
                </div>

                <!-- Dark Mode -->
                <div class="hamburger-item">
                    <div class="hamburger-toggle">
                        <span class="hamburger-item-title">üåô Dark Mode:</span>
                        <label class="mobile-toggle-switch">
                            <input type="checkbox" id="mobileDarkModeToggle">
                            <span class="mobile-toggle-slider"></span>
                        </label>
                    </div>
                </div>

                <!-- Layer Controls -->
                <div class="hamburger-item">
                    <div class="hamburger-item-title">üåä Layer Controls</div>
                    <div class="hamburger-slider-container">
                        <div class="hamburger-slider-label">
                            <span>OpenSeaMap Opacity:</span>
                        </div>
                        <input type="range" id="mobileOpacitySlider" class="hamburger-slider" min="0" max="100" value="30">
                        <div class="hamburger-value-display">
                            Value: <span id="mobileOpacityValue">30</span>%
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Ship Toggle Button -->
    <div class="ship-toggle" id="shipToggle" onclick="toggleShipSimulation()" title="Ship Simulation">
        üö¢
    </div>
    
    
    <!-- Vertical Time Slider (transparent) -->
    <div class="vertical-time-slider" id="verticalTimeSlider">
        <!-- removed labels -->
        <div class="vertical-slider-container">
            <input type="range" id="verticalTimeControl" min="0" max="60" value="0" step="1">
        </div>
        <div class="vertical-time-info" id="verticalTimeInfo">Now</div>
    </div>
    
    <div id="map"></div>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" 
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" 
            crossorigin=""></script>
    
        <script>
        // Istanbul Strait coordinates and boundaries
        const ISTANBUL_STRAIT_CENTER = [41.035, 29.059];
        const INITIAL_ZOOM = 12;
        const MIN_ZOOM = 10;
        const MAX_ZOOM = 15;
        
        // Ship simulation variables
        let shipSimulationActive = false;
        let shipRoute = null;
        let currentTime = 0; // minutes from start
        let animationFrame = null;
        let currentRouteWaypoints = []; // Active route based on direction
        let dynamicMeetingMarker = null; // Dynamic red meeting point marker
        let dynamicMeetingLocked = false; // Persist once created; no repositioning
        let kandilliThresholdAlong = null; // cached along-distance for Arnavutk√∂y (ƒ∞skele wp7)

        // Ship markers and tracking
        let ownShipMarker = null;
        let otherShipMarker = null;

        // GPS snap state
        const GPS_ACCURACY_THRESHOLD_M = 100; // ¬±100 m
        const GPS_DISTANCE_THRESHOLD_NM = 0.27; // ~500 m
        let gpsSnap = {
            enabled: false,
            lastFix: null, // {lat, lng, accuracy}
            lastSnapAt: null,
            requestId: 0,
            activeWatchId: null,
            tempMarker: null,
            tempLine: null
        };

        // Route overlay controls
        let routesVisible = true;
        const routeOverlays = { lines: {}, waypoints: {} }; // keyed by routeId
        
        // Ship class for managing individual ships
        class Ship {
            constructor(id, name, color, defaultSpeed, defaultDirection, defaultPosition, routeId) {
                this.id = id;
                this.name = name;
                this.color = color;
                this.speed = defaultSpeed;
                this.direction = defaultDirection;
                this.marker = null;
                this.customStartPosition = null;
                this.customStartTime = 0;
                this.defaultPosition = defaultPosition; // 'north' or 'south'
                this.routeId = routeId; // 'sancak' | 'orta' | 'iskele'
            }
            
            getStartingWaypoints() {
                const route = ROUTES[this.routeId];
                // Default definition for coords is South -> North
                // Use explicit southbound coords when provided; otherwise reverse default
                if (this.direction === 'southbound' && route.coordsSouthbound) {
                    return [...route.coordsSouthbound];
                }
                return this.direction === 'northbound' ? [...route.coords] : [...route.coords].reverse();
            }
            
            getStartingPosition() {
                const waypoints = this.getStartingWaypoints();
                return this.defaultPosition === 'south' ? 
                    waypoints[0] : waypoints[waypoints.length - 1];
            }
        }

        // Pre-defined routes (South -> North)
        const ROUTES = {
            sancak: {
                id: 'sancak', name: 'Sancak Hat', color: '#8A2BE2',
                // South -> North (default)
                coords: [[40.958136,28.987145],[40.990218,28.997789],[41.019092,28.997982],[41.024038,29.000982],[41.051108,29.046349],[41.069258,29.052381],[41.07438,29.053932],[41.081901,29.062855],[41.099546,29.062341],[41.10505,29.065014],[41.119176,29.086437],[41.122173,29.085274],[41.147458,29.061482],[41.156426,29.061102],[41.179615,29.085255],[41.19303,29.105648],[41.195663,29.109615],[41.201627,29.115277],[41.211146,29.124278]],
                // Southbound override (North -> South)
                coordsSouthbound: [
                    [41.213283,29.119241],[41.203127,29.111410],[41.181070,29.082771],[41.156648,29.056443],
                    [41.148243,29.056269],[41.125494,29.076853],[41.122910,29.077748],[41.104423,29.060519],
                    [41.101691,29.058952],[41.083056,29.059360],[41.074904,29.050634],[41.067693,29.048311],
                    [41.049526,29.036824],[41.046662,29.033149],[41.026724,28.996474],[41.019578,28.992074],
                    [41.004995,28.991895],[40.991191,28.991780]
                ]
            },
            orta: {
                id: 'orta', name: 'Orta Kanal', color: '#FF8C00',
                // South -> North (default)
                coords: [[40.958136,28.987145],[40.990218,28.997789],[41.019092,28.997982],[41.026035,28.999968],[41.050299,29.042151],[41.074474,29.052459],[41.082238,29.060447],[41.099104,29.060643],[41.10535,29.063236],[41.119642,29.080426],[41.124487,29.080577],[41.147697,29.058349],[41.15553,29.058267],[41.180336,29.084119],[41.194786,29.103576],[41.202343,29.113727],[41.212305,29.12166]],
                // Southbound override (North -> South)
                coordsSouthbound: [
                    [41.212305,29.121660],[41.202343,29.113727],[41.194786,29.103576],[41.180336,29.084119],
                    [41.155530,29.058267],[41.147697,29.058349],[41.124487,29.080577],[41.119642,29.080426],
                    [41.105350,29.063236],[41.099104,29.060643],[41.082238,29.060447],[41.074474,29.052459],
                    [41.050299,29.042151],[41.026035,28.999968],[41.019092,28.997982],[40.990218,28.997789],
                    [40.958136,28.987145]
                ]
            },
            iskele: {
                id: 'iskele', name: 'ƒ∞skele Hat', color: '#A52A2A',
                coords: [[40.958136,28.987145],[40.990218,28.997789],[41.019092,28.997982],[41.026035,28.999968],[41.034311,29.007195],[41.049261,29.035879],[41.068108,29.048229],[41.075023,29.052377],[41.082069,29.059913],[41.100637,29.059958],[41.10576,29.061669],[41.124113,29.078085],[41.13039,29.076103],[41.147285,29.061029],[41.1568,29.061663],[41.179465,29.084575],[41.19251,29.104896],[41.195719,29.109395],[41.201617,29.115191],[41.211228,29.124315]]
            }
        };

        // Initialize two ships - both starting northbound from south
        // Defaults: own on ƒ∞skele, other on Sancak
        const ships = [
            new Ship('own', 'OWN SHIP', '#2196F3', 11, 'northbound', 'south', 'iskele'),
            new Ship('other', 'OTHER SHIP', '#FF9800', 7.5, 'northbound', 'south', 'sancak')
        ];
        
        // Quick access to ships
        const ownShip = ships[0];
        const otherShip = ships[1];
        
        // Map layers
        let openSeaMapLayer = null;
        let currentAdvantageEnabled = true;
        let darkModeEnabled = false;
        
        // Define map boundaries to focus on the Istanbul Strait
        const bounds = L.latLngBounds(L.latLng(40.95, 28.9), L.latLng(41.28, 29.22));

        // Initialize the map
        let map = L.map('map', {
            center: ISTANBUL_STRAIT_CENTER,
            zoom: INITIAL_ZOOM,
            minZoom: MIN_ZOOM,
            maxZoom: MAX_ZOOM,
            zoomControl: false,
            attributionControl: false,
            maxBounds: bounds,
            maxBoundsViscosity: 1.0 // Makes the bounds hard, preventing dragging outside
        });
        
        // (Replaced single fixed route with 3 predefined routes below)

        // Calculate distances between waypoints
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 3440.065; // Nautical miles
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // (Per-ship distances are computed on-the-fly; no global route distances needed)
        
        // Base map layer
        const BASEMAPS = {
            light: 'https://basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
            dark:  'https://basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png'
        };
        let baseLayer = L.tileLayer(BASEMAPS.light, {
            attribution: '¬© OpenStreetMap contributors, ¬© CartoDB',
            maxZoom: MAX_ZOOM
        });
        
        baseLayer.addTo(map);

        // Istanbul Strait Traffic Separation Scheme (manual overlay)
        let tssLayerGroup = L.layerGroup();

        const istanbulStraitTSS = {
            centerLine: [
                [41.225717, 29.132567],
                [41.202050, 29.113400],
                [41.180383, 29.084233],
                [41.155383, 29.058383],
                [41.147733, 29.058383],
                [41.122050, 29.082900],
                [41.119217, 29.082900],
                [41.105383, 29.063067],
                [41.099050, 29.060733],
                [41.082050, 29.060400],
                [41.074550, 29.052400],
                [41.050717, 29.042883],
                [41.024883, 28.998067],
                [41.022383, 28.996233],
                [41.001550, 28.995400]
            ],
            easternBoundary: [
                [40.999050, 29.000567],
                [41.017383, 29.000733],
                [41.024050, 29.002917],
                [41.050717, 29.048900],
                [41.074050, 29.055067],
                [41.081883, 29.064883],
                [41.099883, 29.063717],
                [41.104900, 29.066217],
                [41.119050, 29.089550],
                [41.122383, 29.088733],
                [41.146550, 29.064400],
                [41.157050, 29.063550],
                [41.179050, 29.086233],
                [41.193550, 29.112567],
                [41.204050, 29.119567],
                [41.221717, 29.142067]
            ],
            westernBoundary: [
                [41.228950, 29.124567],
                [41.204050, 29.110067],
                [41.199050, 29.099567],
                [41.174217, 29.074567],
                [41.157717, 29.054383],
                [41.149550, 29.054067],
                [41.123733, 29.076550],
                [41.103217, 29.057900],
                [41.084550, 29.058383],
                [41.081050, 29.056233],
                [41.075217, 29.048567],
                [41.067883, 29.047067],
                [41.048550, 29.034083],
                [41.027883, 28.995067],
                [41.020550, 28.990400],
                [41.004050, 28.989900]
            ]
        };

        function createManualTSS() {
            const isDark = typeof darkModeEnabled !== 'undefined' && darkModeEnabled;
            const centerLineStyle = isDark ?
                { color: '#9a7fa0', weight: 6, opacity: 0.6, dashArray: null } :
                { color: '#eb66c8', weight: 8, opacity: 0.9, dashArray: null };
            const boundaryCommon = isDark ? { color: '#9a7fa0', weight: 2, opacity: 0.6, dashArray: '10, 5' }
                                          : { color: '#eb66c8', weight: 3, opacity: 0.9, dashArray: '10, 5' };
            const easternBoundaryStyle = boundaryCommon;
            const westernBoundaryStyle = boundaryCommon;

            tssLayerGroup.clearLayers();

            const centerLine = L.polyline(istanbulStraitTSS.centerLine, centerLineStyle).bindPopup(`
                <div style="font-family: 'Courier New', monospace; font-size: 12px;">
                    <strong>TSS CENTER LINE</strong><br>
                    <em>Traffic Separation Center</em><br>
                    <hr style="margin: 5px 0;">
                    üìè <strong>Points:</strong> 15 official coordinates
                </div>
            `);
            const easternBoundaryLine = L.polyline(istanbulStraitTSS.easternBoundary, easternBoundaryStyle).bindPopup(`
                <div style="font-family: 'Courier New', monospace; font-size: 12px;">
                    <strong>EASTERN BOUNDARY</strong><br>
                    <em>Traffic Lane Eastern Limit</em><br>
                    <hr style="margin: 5px 0;">
                    üìè <strong>Points:</strong> 16 official coordinates
                </div>
            `);
            const westernBoundaryLine = L.polyline(istanbulStraitTSS.westernBoundary, westernBoundaryStyle).bindPopup(`
                <div style="font-family: 'Courier New', monospace; font-size: 12px;">
                    <strong>WESTERN BOUNDARY</strong><br>
                    <em>Traffic Lane Western Limit</em><br>
                    <hr style="margin: 5px 0;">
                    üìè <strong>Points:</strong> 16 official coordinates
                </div>
            `);

            tssLayerGroup.addLayer(centerLine);
            tssLayerGroup.addLayer(easternBoundaryLine);
            tssLayerGroup.addLayer(westernBoundaryLine);
            tssLayerGroup.addTo(map);
        }

        createManualTSS();
        
        // Initialize OpenSeaMap layer
        function initializeOpenSeaMap() {
            openSeaMapLayer = L.tileLayer('https://tiles.openseamap.org/seamark/{z}/{x}/{y}.png', {
                attribution: '¬© OpenSeaMap contributors',
                opacity: 0.3,
                maxZoom: MAX_ZOOM
            });
            openSeaMapLayer.addTo(map);
        }
        
        // Initialize map
        initializeOpenSeaMap();
        
        // Apply default start positions for both ships based on their current directions
        function applyDefaultStartPositions() {
            const ref = ROUTES.orta.coords;
            // Northbound defaults: own->wp2, other->wp3
            // Southbound defaults: own->wp16, other->wp14
            const northDefaults = {
                own: ref[1],   // wp2
                other: ref[2]  // wp3
            };
            const southDefaults = {
                own: ref[15],  // wp16 (0-based)
                other: ref[13] // wp14
            };

            // Own ship
            const ownDefault = ownShip.direction === 'northbound' ? northDefaults.own : southDefaults.own;
            ownShip.customStartPosition = L.latLng(ownDefault[0], ownDefault[1]);
            ownShip.customStartTime = 0;

            // Other ship
            const otherDefault = otherShip.direction === 'northbound' ? northDefaults.other : southDefaults.other;
            otherShip.customStartPosition = L.latLng(otherDefault[0], otherDefault[1]);
            otherShip.customStartTime = 0;
        }

        // Ship direction selection
        function selectShipDirection(shipName, direction) {
            const ship = shipName === 'own' ? ownShip : otherShip;
            ship.direction = direction;
            
            // Set default route to Orta Kanal for southbound ships
            if (direction === 'southbound') {
                ship.routeId = 'orta';
                // Update the route select UI and disable ƒ∞skele for southbound
                const routeSelect = document.getElementById(shipName + 'RouteSelect');
                if (routeSelect) {
                    routeSelect.value = 'orta';
                    // Remove ƒ∞skele option entirely when southbound
                    const iskeleOpt = routeSelect.querySelector('option[value="iskele"]');
                    if (iskeleOpt) {
                        iskeleOpt.remove();
                    }
                }
            } else {
                // Re-enable all options when switching back to northbound
                const routeSelect = document.getElementById(shipName + 'RouteSelect');
                if (routeSelect) {
                    // Add ƒ∞skele back if missing
                    if (!routeSelect.querySelector('option[value="iskele"]')) {
                        const opt = document.createElement('option');
                        opt.value = 'iskele';
                        opt.textContent = 'ƒ∞skele Hat';
                        routeSelect.appendChild(opt);
                    }
                }
            }
            
            // Update UI
            document.getElementById(shipName + 'Northbound').classList.remove('selected');
            document.getElementById(shipName + 'Southbound').classList.remove('selected');
            document.getElementById(shipName + direction.charAt(0).toUpperCase() + direction.slice(1)).classList.add('selected');
            
            // Reposition both ships to their direction-based defaults
            applyDefaultStartPositions();
            
            // If simulation is active, restart it
            if (shipSimulationActive) {
                startShipSimulation();
            }
            updateAdvisoryBanners();
            updateRoutesOverlay();
        }
        
        // Project point onto line segment
        function projectPointOnSegment(point, segmentStart, segmentEnd) {
            const dx = segmentEnd[1] - segmentStart[1];
            const dy = segmentEnd[0] - segmentStart[0];
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length === 0) return segmentStart;
            
            const t = Math.max(0, Math.min(1, 
                ((point.lng - segmentStart[1]) * dx + (point.lat - segmentStart[0]) * dy) / (length * length)
            ));
            
            return [
                segmentStart[0] + t * dy,
                segmentStart[1] + t * dx
            ];
        }
        
        // Find distance along route for a given position
        function findDistanceAlongRoute(position, waypoints, distances) {
            let minDistance = Infinity;
            let bestSegmentIndex = 0;
            let bestProgress = 0;
            
            // Check each route segment to find closest point
            for (let i = 0; i < waypoints.length - 1; i++) {
                const segmentStart = waypoints[i];
                const segmentEnd = waypoints[i + 1];
                const projectedPoint = projectPointOnSegment(position, segmentStart, segmentEnd);
                
                const distance = calculateDistance(
                    position.lat, position.lng,
                    projectedPoint[0], projectedPoint[1]
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    bestSegmentIndex = i;
                    
                    // Calculate progress along this segment
                    const segmentLength = calculateDistance(
                        segmentStart[0], segmentStart[1],
                        segmentEnd[0], segmentEnd[1]
                    );
                    
                    const progressLength = calculateDistance(
                        segmentStart[0], segmentStart[1],
                        projectedPoint[0], projectedPoint[1]
                    );
                    
                    bestProgress = segmentLength > 0 ? progressLength / segmentLength : 0;
                }
            }
            
            // Calculate total distance to this point along route
            let totalDistance = 0;
            for (let i = 0; i < bestSegmentIndex; i++) {
                totalDistance += distances[i];
            }
            totalDistance += distances[bestSegmentIndex] * bestProgress;
            
            return totalDistance;
        }

        // Find nearest point on route and along-distance + gap distance (nm)
        function findNearestOnRoute(position, waypoints, distances) {
            let minDistance = Infinity;
            let bestSegmentIndex = 0;
            let bestProgress = 0;
            let bestPoint = waypoints[0];

            for (let i = 0; i < waypoints.length - 1; i++) {
                const a = waypoints[i];
                const b = waypoints[i + 1];
                const p = projectPointOnSegment(position, a, b);
                const d = calculateDistance(position.lat, position.lng, p[0], p[1]);
                if (d < minDistance) {
                    minDistance = d;
                    bestSegmentIndex = i;
                    const segLen = calculateDistance(a[0], a[1], b[0], b[1]);
                    const progLen = calculateDistance(a[0], a[1], p[0], p[1]);
                    bestProgress = segLen > 0 ? progLen / segLen : 0;
                    bestPoint = p;
                }
            }

            // Accumulate distance along up to best segment
            let distanceAlong = 0;
            for (let i = 0; i < bestSegmentIndex; i++) distanceAlong += distances[i] || 0;
            distanceAlong += (distances[bestSegmentIndex] || 0) * bestProgress;

            return {
                distanceAlong,
                snapped: bestPoint,
                segmentIndex: bestSegmentIndex,
                progress: bestProgress,
                distanceToRouteNm: minDistance
            };
        }

        // Status banner helper
        function showStatusBanner(message, type /* 'success' | 'error' | 'info' */) {
            const container = document.getElementById('advisoryBanners');
            const el = document.getElementById('bannerStatus');
            if (!container || !el) return;
            container.style.display = 'flex';
            el.textContent = message;
            let klass = 'banner banner-status';
            if (type === 'success') klass += ' success';
            else if (type === 'error') klass += ' error';
            else if (type === 'info') klass += ' info';
            el.className = klass;
            el.style.display = 'block';
            // Auto-hide: info shorter (3s), others 4s
            clearTimeout(el._hideTimer);
            const dur = type === 'info' ? 3000 : 4000;
            el._hideTimer = setTimeout(() => { el.style.display = 'none'; }, dur);
        }

        // Calculate bearing between two points
        function calculateBearing(lat1, lng1, lat2, lng2) {
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const lat1Rad = lat1 * Math.PI / 180;
            const lat2Rad = lat2 * Math.PI / 180;
            
            const y = Math.sin(dLng) * Math.cos(lat2Rad);
            const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLng);
            
            let bearing = Math.atan2(y, x) * 180 / Math.PI;
            return (bearing + 360) % 360;
        }

        // ===== Simple Current Effect Model (SOG-based) =====
        // We apply fixed, invisible current effects per route/segment.
        // - All input speeds are SOG (already current-adjusted). Effects modify SOG to reflect local current.
        // - ƒ∞skele northbound (updated):
        //     wp5‚Äìwp6:   +1.3 kts  => segment index 4
        //     wp6‚Äìwp7:   +0.5 kts  => segment index 5
        //     wp7‚Äìwp9:   -0.3 kts  => segment indices 6 and 7
        //     wp11‚Äìwp12: +1.0 kts  => segment index 10 (unchanged)
        //     wp13‚Äìwp15: +0.5 kts  => segment indices 12 and 13
        // - Orta northbound (updated):
        //     wp5‚Äìwp6: last 25%: -0.3 kts (position-based)
        //     wp6‚Äìwp7:          -0.3 kts (entire segment)
        // - Southbound effects (as specified):
        //   Orta (SB, 17 WPs):
        //     wp12‚Äìwp13: +1.5 kts => segment index 11
        //     wp13‚Äìwp14: +1.0 kts => segment index 12
        //   Sancak (SB, 18 WPs):
        //     wp7‚Äìwp8:   -1.0 kts => segment index 6
        //     wp12‚Äìwp13: +0.5 kts => segment index 11
        //     wp13‚Äìwp15: +0.3 kts => segment indices 12 and 13

        function getSegmentEffectiveSpeedKts(ship, segmentIndex) {
            let speed = ship.speed; // SOG base input
            let originalSpeed = speed;
            
            // Apply current effects only if toggle is enabled
            if (currentAdvantageEnabled) {
                if (ship.direction === 'northbound') {
                    if (ship.routeId === 'iskele') {
                        if (segmentIndex === 4) speed += 1.3;       // wp5->wp6 (updated)
                        else if (segmentIndex === 5) speed += 0.5;  // wp6->wp7 (updated)
                        else if (segmentIndex === 10) speed += 1.0; // wp11->wp12 (unchanged)
                        else if (segmentIndex === 6 || segmentIndex === 7) speed -= 0.3; // wp7->wp9 (new)
                        else if (segmentIndex === 12 || segmentIndex === 13) speed += 0.5; // wp13->wp15 (new)
                    } else if (ship.routeId === 'orta') {
                        if (segmentIndex === 5) speed -= 0.3; // wp6->wp7 (new)
                    } else if (ship.routeId === 'sancak') {
                        // Northbound Sancak: wp12->wp13 = segment index 11
                        if (segmentIndex === 11) speed += 0.6;
                    }
                } else if (ship.direction === 'southbound') {
                    if (ship.routeId === 'orta' && ROUTES.orta.coordsSouthbound) {
                        if (segmentIndex === 11) speed += 1.5; // wp12->wp13
                        else if (segmentIndex === 12) speed += 1.0; // wp13->wp14
                    } else if (ship.routeId === 'sancak' && ROUTES.sancak.coordsSouthbound) {
                        if (segmentIndex === 6) speed -= 1.0; // wp7->wp8
                        else if (segmentIndex === 11) speed += 0.5; // wp12->wp13
                        else if (segmentIndex >= 12 && segmentIndex <= 13) speed += 0.3; // wp13->wp15
                    }
                }
            }
            
            // Debug logging removed
            
            // Prevent zero/negative effective speeds
            return Math.max(speed, 0.1);
        }

        function getSegmentDistances(waypoints) {
            const dists = [];
            for (let i = 0; i < waypoints.length - 1; i++) {
                const dist = calculateDistance(
                    waypoints[i][0], waypoints[i][1],
                    waypoints[i + 1][0], waypoints[i + 1][1]
                );
                dists.push(dist);
            }
            return dists;
        }

        // ===== Turning loss helpers (Option A approximated via distance windows) =====
        function angleDiff(a, b) {
            let d = Math.abs(a - b) % 360;
            return d > 180 ? 360 - d : d;
        }
        function turnLossRatio(angleDeg) {
            if (angleDeg < 10) return 0;
            if (angleDeg < 20) return 0.05 + (angleDeg - 10) * (0.10 - 0.05) / 10; // 5%..10%
            if (angleDeg < 30) return 0.10 + (angleDeg - 20) * (0.12 - 0.10) / 10; // 10%..12%
            if (angleDeg < 40) return 0.12 + (angleDeg - 30) * (0.15 - 0.12) / 10; // 12%..15%
            if (angleDeg < 50) return 0.15 + (angleDeg - 40) * (0.18 - 0.15) / 10; // 15%..18%
            const up = 0.18 + Math.min(40, angleDeg - 50) * (0.25 - 0.18) / 40; // 18%..25%
            return Math.min(0.25, up);
        }
        function tauDownMinutes(angleDeg) { return Math.min(1.2, 0.3 + 0.008 * angleDeg); }
        function tauUpMinutes(angleDeg) { return Math.min(3.0, 0.6 + 0.03 * angleDeg); }
        function getEffectiveSpeedWithTurn(ship, segIndex, offsetInSegNm, waypoints, distances) {
            const currWith = getSegmentEffectiveSpeedKts(ship, segIndex);
            const segLen = distances[segIndex] || 0;
            if (segLen <= 0 || !isFinite(currWith)) return Math.max(0.1, currWith || ship.speed || 0.1);
            const brgAt = (i) => calculateBearing(waypoints[i][0], waypoints[i][1], waypoints[i + 1][0], waypoints[i + 1][1]);
            const hasPrev = segIndex > 0;
            const hasNext = segIndex + 1 < distances.length;
            const prevWith = hasPrev ? getSegmentEffectiveSpeedKts(ship, segIndex - 1) : currWith;

            // Angles at junctions
            const angleAhead = hasNext ? angleDiff(brgAt(segIndex), brgAt(segIndex + 1)) : 0;
            const angleBehind = hasPrev ? angleDiff(brgAt(segIndex - 1), brgAt(segIndex)) : 0;

            // Tail (approaching next WP): ramp 0->1 over last Ltail nm
            let tailFactor = 0;
            if (hasNext && angleAhead >= 10) {
                // Tail window shortened to 1/3 of previous length
                const Ltail = Math.min(segLen, (currWith * tauDownMinutes(angleAhead) / 60) / 3);
                const startTail = Math.max(0, segLen - Ltail);
                if (offsetInSegNm >= startTail) {
                    tailFactor = Math.min(1, (offsetInSegNm - startTail) / Math.max(0.0001, Ltail));
                }
            }

            // Head (after previous WP): ramp 1->0 over first Lhead nm
            let headFactor = 0;
            if (hasPrev && angleBehind >= 10) {
                const Lhead = Math.min(segLen, currWith * tauUpMinutes(angleBehind) / 60);
                if (offsetInSegNm <= Lhead) {
                    headFactor = Math.max(0, 1 - (offsetInSegNm / Math.max(0.0001, Lhead)));
                }
            }

            // Candidate speeds
            let eff = currWith;
            if (tailFactor > 0) {
                const lossTail = turnLossRatio(angleAhead);
                const candidateTail = currWith * (1 - lossTail * tailFactor);
                eff = Math.min(eff, candidateTail);
            }
            if (headFactor > 0) {
                const lossHead = turnLossRatio(angleBehind);
                // Blend from pre-turn penalized speed to current baseline across head window
                const preTurnDip = prevWith * (1 - lossHead);
                const blended = headFactor * preTurnDip + (1 - headFactor) * currWith;
                eff = Math.min(eff, blended);
            }

            // Additional partial current effect (only last 25% of segment):
            // Northbound Orta route, wp5->wp6 (segment index 4): apply -0.3 kts only near wp6
            if (currentAdvantageEnabled && ship.direction === 'northbound' && ship.routeId === 'orta' && segIndex === 4) {
                const segLenLocal = segLen; // already defined above
                if (segLenLocal > 0 && offsetInSegNm >= 0.75 * segLenLocal) {
                    eff -= 0.3;
                }
            }

            return Math.max(0.1, eff);
        }

        function getTotalDistance(distances) {
            return distances.reduce((a, b) => a + b, 0);
        }

        // Default marker start offset along route:
        // own ship at wp2, other ship at wp3 (to ease dragging on mobile)
        function getDefaultStartDistanceAlongRoute(ship, distances) {
            const targetWpIndexOneBased = ship.id === 'own' ? 2 : 3;
            // Sum segments up to wpN (exclusive): e.g., wp2 => sum of segment[0]
            let sum = 0;
            for (let i = 0; i < Math.max(0, targetWpIndexOneBased - 1); i++) {
                if (i < distances.length) sum += distances[i];
            }
            return sum;
        }

        // Advance along route accounting for per-segment effective speed (kts)
        function advanceAlongRouteByTime(ship, startDistance, timeMinutes, waypoints, distances) {
            const total = getTotalDistance(distances);
            if (total <= 0 || waypoints.length < 2) {
                return {
                    position: waypoints[0],
                    bearing: 0,
                    segmentIndex: 0,
                    nextWaypoint: 1,
                    distanceToNext: distances[0] || 0,
                    eta: 0,
                    segmentLengthNm: distances[0] || 0,
                    offsetInSegmentNm: 0,
                    segmentProgress: 0
                };
            }

            let start = Math.max(0, Math.min(total, startDistance));
            let remainingTime = Math.max(0, timeMinutes);

            // Find starting segment and offset
            let acc = 0;
            let segIndex = 0;
            while (segIndex < distances.length && acc + distances[segIndex] <= start) {
                acc += distances[segIndex];
                segIndex++;
            }

            if (segIndex >= distances.length) {
                const last = waypoints.length - 1;
                const brg = calculateBearing(
                    waypoints[last - 1][0], waypoints[last - 1][1],
                    waypoints[last][0], waypoints[last][1]
                );
                return { position: waypoints[last], bearing: brg, segmentIndex: last - 1, nextWaypoint: null, distanceToNext: 0, eta: 0, segmentLengthNm: distances[last - 1] || 0, offsetInSegmentNm: distances[last - 1] || 0, segmentProgress: 1 };
            }

            let offsetInSeg = start - acc; // nm

            // If no time to advance, return position at current offset within segment
            if (remainingTime <= 0) {
                const segLen = distances[segIndex];
                const progress = segLen > 0 ? Math.max(0, Math.min(1, offsetInSeg / segLen)) : 0;
                const lat1 = waypoints[segIndex][0], lng1 = waypoints[segIndex][1];
                const lat2 = waypoints[segIndex + 1][0], lng2 = waypoints[segIndex + 1][1];
                const lat = lat1 + (lat2 - lat1) * progress;
                const lng = lng1 + (lng2 - lng1) * progress;
                const brg = calculateBearing(lat1, lng1, lat2, lng2);
                const distToNext = Math.max(0, segLen - offsetInSeg);
                const effNmPerMin = getEffectiveSpeedWithTurn(ship, segIndex, offsetInSeg, waypoints, distances) / 60.0;
                const eta = effNmPerMin > 0 ? (distToNext / effNmPerMin) : 0;
                return {
                    position: [lat, lng],
                    bearing: brg,
                    segmentIndex: segIndex,
                    nextWaypoint: segIndex + 1 < waypoints.length ? segIndex + 1 : null,
                    distanceToNext: distToNext,
                    eta: eta,
                    segmentLengthNm: segLen,
                    offsetInSegmentNm: offsetInSeg,
                    segmentProgress: progress
                };
            }

            while (remainingTime > 0 && segIndex < distances.length) {
                const segLen = distances[segIndex];
                const effKts = getEffectiveSpeedWithTurn(ship, segIndex, offsetInSeg, waypoints, distances);
                const effNmPerMin = effKts / 60.0;
                const remainingSegDist = Math.max(0, segLen - offsetInSeg);
                const timeToFinishSeg = effNmPerMin > 0 ? (remainingSegDist / effNmPerMin) : Infinity;

                if (remainingTime < timeToFinishSeg) {
                    // We stay within this segment
                    const moved = remainingTime * effNmPerMin; // nm
                    const progress = Math.max(0, Math.min(1, (offsetInSeg + moved) / segLen));
                    const lat1 = waypoints[segIndex][0], lng1 = waypoints[segIndex][1];
                    const lat2 = waypoints[segIndex + 1][0], lng2 = waypoints[segIndex + 1][1];
                    const lat = lat1 + (lat2 - lat1) * progress;
                    const lng = lng1 + (lng2 - lng1) * progress;
                    const brg = calculateBearing(lat1, lng1, lat2, lng2);
                    const distToNext = Math.max(0, segLen - (offsetInSeg + moved));
                    const eta = effNmPerMin > 0 ? (distToNext / effNmPerMin) : 0;
                    return {
                        position: [lat, lng],
                        bearing: brg,
                        segmentIndex: segIndex,
                        nextWaypoint: segIndex + 1 < waypoints.length ? segIndex + 1 : null,
                        distanceToNext: distToNext,
                        eta: eta,
                        segmentLengthNm: segLen,
                        offsetInSegmentNm: Math.min(segLen, offsetInSeg + moved),
                        segmentProgress: progress
                    };
                }

                // Move to next segment
                remainingTime -= timeToFinishSeg;
                acc += segLen;
                segIndex++;
                offsetInSeg = 0;
            }

            // If we finished all segments or time ran exactly to end
            const lastIndex = waypoints.length - 1;
            const lastBearing = calculateBearing(
                waypoints[lastIndex - 1][0], waypoints[lastIndex - 1][1],
                waypoints[lastIndex][0], waypoints[lastIndex][1]
            );
            return {
                position: waypoints[lastIndex],
                bearing: lastBearing,
                segmentIndex: lastIndex - 1,
                nextWaypoint: null,
                distanceToNext: 0,
                eta: 0,
                segmentLengthNm: distances[lastIndex - 1] || 0,
                offsetInSegmentNm: distances[lastIndex - 1] || 0,
                segmentProgress: 1
            };
        }

        // SOG-based ship position with simple ƒ∞skele advantages and per-segment speeds
        function getShipPositionAtTime(ship, timeMinutes) {
            // Ship route
            const shipWaypoints = ship.getStartingWaypoints();
            const shipDistances = getSegmentDistances(shipWaypoints);

            // Determine start offset along route
            let startDistance = getDefaultStartDistanceAlongRoute(ship, shipDistances);

            // If custom start is set (from dragging), use that exact offset and reset start time reference
            if (ship.customStartPosition) {
                const customOffset = findDistanceAlongRoute(ship.customStartPosition, shipWaypoints, shipDistances);
                const elapsed = Math.max(0, timeMinutes - ship.customStartTime);
                return advanceAlongRouteByTime(ship, customOffset, elapsed, shipWaypoints, shipDistances);
            }

            // Normal advance from default offset
            return advanceAlongRouteByTime(ship, startDistance, timeMinutes, shipWaypoints, shipDistances);
        }
        

        // ===== Overtaking helpers based on Orta Kanal reference =====
        function getReferenceRouteAndDistances() {
            const refCoords = ROUTES.orta.coords;
            const refDistances = getSegmentDistances(refCoords);
            return { refCoords, refDistances };
        }

        function progressAlongReference(lat, lng) {
            const { refCoords, refDistances } = getReferenceRouteAndDistances();
            return findDistanceAlongRoute({ lat, lng }, refCoords, refDistances);
        }

        function getPointAlongRouteByDistance(waypoints, distances, distanceAlong) {
            let acc = 0;
            for (let i = 0; i < distances.length; i++) {
                const seg = distances[i];
                if (distanceAlong <= acc + seg) {
                    const frac = seg > 0 ? Math.max(0, Math.min(1, (distanceAlong - acc) / seg)) : 0;
                    const lat1 = waypoints[i][0], lng1 = waypoints[i][1];
                    const lat2 = waypoints[i + 1][0], lng2 = waypoints[i + 1][1];
                    const lat = lat1 + (lat2 - lat1) * frac;
                    const lng = lng1 + (lng2 - lng1) * frac;
                    return [lat, lng];
                }
                acc += seg;
            }
            return waypoints[waypoints.length - 1];
        }

        function calculateEncounterEvent() {
            // Handle both overtaking (same direction) and meeting (opposite directions)
            const ownNorth = ownShip.direction === 'northbound';
            const othNorth = otherShip.direction === 'northbound';
            const bothNorth = ownNorth && othNorth;
            const bothSouth = !ownNorth && !othNorth;
            const opposite = ownNorth !== othNorth;

            const maxTime = 120; // minutes
            const dt = 0.25; // minutes

            function alongDiff(t) {
                const o = getShipPositionAtTime(ownShip, t);
                const p = getShipPositionAtTime(otherShip, t);
                const a = progressAlongReference(o.position[0], o.position[1]);
                const b = progressAlongReference(p.position[0], p.position[1]);
                // Choose monotone-increasing diff for root finding
                if (bothNorth) return a - b;           // catch-up northbound
                if (bothSouth) return b - a;           // catch-up southbound
                if (ownNorth && !othNorth) return a - b; // meeting: a increases, b decreases
                if (!ownNorth && othNorth) return b - a; // meeting: b increases, a decreases
                return a - b;
            }

            const type = (bothNorth || bothSouth) ? 'overtake' : 'meet';

            let f0 = alongDiff(0);
            if (type === 'overtake') {
                // If faster ship is already ahead (no catch-up needed), do not create an event
                if (f0 >= 0) return null;
            } else { // meet
                // If f0 >= 0 under our monotone diff, ships are diverging => no meeting ahead
                if (f0 >= 0) return null;
            }

            let left = 0, right = null;
            let prevT = 0, prevF = f0;
            for (let t = dt; t <= maxTime; t += dt) {
                const ft = alongDiff(t);
                if (prevF <= 0 && ft >= 0) { right = t; left = prevT; break; }
                prevT = t; prevF = ft;
            }
            if (right === null) return null; // no event in window

            for (let i = 0; i < 14; i++) {
                const mid = (left + right) / 2;
                if (alongDiff(mid) < 0) left = mid; else right = mid;
            }
            const tStar = right;
            const o = getShipPositionAtTime(ownShip, tStar);
            const a = progressAlongReference(o.position[0], o.position[1]);
            const { refCoords, refDistances } = getReferenceRouteAndDistances();
            const point = getPointAlongRouteByDistance(refCoords, refDistances, a);
            return { time: tStar, point, along: a, type };
        }

        // Create overtaking/meeting point marker once (persist)
        function updateDynamicMeetingPoint() {
            // If we already decided (created or explicitly not created), do nothing
            if (dynamicMeetingLocked) return;
            if (dynamicMeetingMarker) return;
            const evt = calculateEncounterEvent();
            if (!evt) {
                // If ships are same direction and no overtake event, lock as never-occurring edge case
                const ownNorth = ownShip.direction === 'northbound';
                const othNorth = otherShip.direction === 'northbound';
                if (ownNorth === othNorth) dynamicMeetingLocked = true;
                return;
            }
            const dynamicMeetingIcon = L.divIcon({
                className: 'meeting-point-marker-container',
                html: '<div class="meeting-point-marker"></div>',
                iconSize: [24, 24],
                iconAnchor: [12, 12]
            });
            dynamicMeetingMarker = L.marker(evt.point, { icon: dynamicMeetingIcon, zIndexOffset: 1100 });
            const title = evt.type === 'meet' ? 'Meeting Point' : 'Overtaking Point';
            dynamicMeetingMarker.bindPopup(`
                <div style="font-family: 'Courier New', monospace; font-size: 12px; text-align: center;">
                    üî¥ <strong>${title}</strong><br>
                    <hr style="margin: 5px 0;">
                    üï∞ <strong>Time:</strong> +${evt.time.toFixed(2)} min<br>
                    üìç <strong>Lat:</strong> ${evt.point[0].toFixed(5)}¬∞<br>
                    üìç <strong>Lng:</strong> ${evt.point[1].toFixed(5)}¬∞
                </div>
            `);
            dynamicMeetingMarker.addTo(map);
            // Lock so it doesn't move/disappear after creation
            dynamicMeetingLocked = true;
        }

        // Reset persistent meeting/overtaking marker so it can be recomputed
        function resetDynamicMeetingPoint() {
            try {
                if (dynamicMeetingMarker) { map.removeLayer(dynamicMeetingMarker); }
            } catch(e){}
            dynamicMeetingMarker = null;
            dynamicMeetingLocked = false;
        }

        // ===== GPS Snap: UI + behavior =====
        function updateGpsSnapUI() {
            const panel = document.getElementById('gpsSnapPanel');
            const sw = document.getElementById('gpsSnapSwitch');
            if (!panel || !sw) return;
            sw.checked = !!gpsSnap.enabled;
        }

        function stopGpsInterval() {
            // no interval in simplified UX
            // Also stop any active watch
            if (gpsSnap.activeWatchId != null && navigator.geolocation && navigator.geolocation.clearWatch) {
                try { navigator.geolocation.clearWatch(gpsSnap.activeWatchId); } catch(e){}
                gpsSnap.activeWatchId = null;
            }
        }

        function setGpsSnapEnabled(on) {
            gpsSnap.enabled = !!on;
            if (!on) {
                // On turning off: snap once (so user can quickly refresh), suppress warnings and success; then disable
                triggerGpsSnapOnce({ suppressSuccess: true, suppressWarnings: true }, () => {
                    stopGpsInterval();
                    gpsSnap.enabled = false;
                    updateGpsSnapUI();
                    // Subtle info notice
                    showStatusBanner('GPS verisi kapatƒ±ldƒ±', 'info');
                });
            } else {
                // On turning on: snap once immediately
                triggerGpsSnapOnce({ suppressSuccess: false }, () => { updateGpsSnapUI(); });
            }
        }

        function triggerGpsSnapOnce(options, cb) {
            if (typeof options === 'function') { cb = options; options = {}; }
            if (!('geolocation' in navigator)) {
                showStatusBanner('Geolocation desteklenmiyor', 'error');
                if (cb) cb();
                return;
            }
            // Concurrency guard
            gpsSnap.requestId = (gpsSnap.requestId || 0) + 1;
            const rid = gpsSnap.requestId;

            // Ensure no previous watch stays around
            if (gpsSnap.activeWatchId != null && navigator.geolocation && navigator.geolocation.clearWatch) {
                try { navigator.geolocation.clearWatch(gpsSnap.activeWatchId); } catch(e){}
                gpsSnap.activeWatchId = null;
            }

            const opts = { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 };
            let settled = false;
            const finish = () => {
                if (settled) return; settled = true;
                if (gpsSnap.activeWatchId != null && navigator.geolocation && navigator.geolocation.clearWatch) {
                    try { navigator.geolocation.clearWatch(gpsSnap.activeWatchId); } catch(e){}
                    gpsSnap.activeWatchId = null;
                }
                if (cb) cb();
            };

            try {
                const wid = navigator.geolocation.watchPosition(pos => {
                    if (rid !== gpsSnap.requestId) return; // stale callback
                    const { latitude, longitude, accuracy } = pos.coords || {};
                    gpsSnap.lastFix = { lat: latitude, lng: longitude, accuracy };
                    updateGpsSnapUI();
                    snapOwnShipToNearestRoute(latitude, longitude, accuracy, options || {});
                    finish();
                }, err => {
                    if (rid !== gpsSnap.requestId) return; // stale callback
                    showStatusBanner('Konum alƒ±namadƒ±: ' + (err && err.message ? err.message : 'Hata'), 'error');
                    finish();
                }, opts);
                gpsSnap.activeWatchId = wid;
                // Safety timeout to ensure finish
                setTimeout(() => { if (!settled) finish(); }, 12000);
            } catch(e) {
                showStatusBanner('Geolocation izleme ba≈ülatƒ±lamadƒ±', 'error');
                finish();
            }
        }

        function snapOwnShipToNearestRoute(lat, lng, accuracyM, opts) {
            try {
                const waypoints = ownShip.getStartingWaypoints();
                const distances = getSegmentDistances(waypoints);
                const nearest = findNearestOnRoute({ lat, lng }, waypoints, distances);
                const gapNm = nearest.distanceToRouteNm;
                if (!(opts && opts.suppressWarnings)) {
                    if (gapNm > GPS_DISTANCE_THRESHOLD_NM) {
                        showStatusBanner(`GPS noktasƒ± rotadan uzak (~${gapNm.toFixed(2)} nm) ‚Äî en yakƒ±n noktaya ta≈üƒ±ndƒ±`, 'error');
                    }
                    if (typeof accuracyM === 'number' && accuracyM > GPS_ACCURACY_THRESHOLD_M) {
                        showStatusBanner(`D√º≈ü√ºk doƒüruluk (¬±${Math.round(accuracyM)} m) ‚Äî yine de hizalandƒ±`, 'error');
                    }
                }

                const snapped = nearest.snapped; // [lat,lng]
                ownShip.customStartPosition = L.latLng(snapped[0], snapped[1]);
                ownShip.customStartTime = currentTime; // referansƒ± mevcut sim√ºlasyon zamanƒ±
                updateShipPositions();
                updateDynamicMeetingPoint();
                updateAdvisoryBanners();

                // G√∂rsel iz: her seferinde g√ºncel mavi nokta ve kesikli √ßizgi (√∂ncekileri temizle)
                if (typeof L !== 'undefined' && map && Array.isArray(snapped)) {
                    try {
                        if (gpsSnap.tempMarker) { try { map.removeLayer(gpsSnap.tempMarker); } catch(e){} }
                        if (gpsSnap.tempLine) { try { map.removeLayer(gpsSnap.tempLine); } catch(e){} }
                        const gpsPt = L.latLng(lat, lng);
                        const snapPt = L.latLng(snapped[0], snapped[1]);
                        gpsSnap.tempMarker = L.circleMarker(gpsPt, {
                            radius: 4,
                            color: '#00E5FF',
                            fillColor: '#00E5FF',
                            fillOpacity: 0.85,
                            weight: 1
                        }).addTo(map);
                        gpsSnap.tempLine = L.polyline([gpsPt, snapPt], {
                            color: '#00E5FF',
                            weight: 2,
                            dashArray: '4,4',
                            opacity: 0.8
                        }).addTo(map);
                        setTimeout(() => {
                            if (gpsSnap.tempMarker) { try { map.removeLayer(gpsSnap.tempMarker); } catch(e){} gpsSnap.tempMarker = null; }
                            if (gpsSnap.tempLine) { try { map.removeLayer(gpsSnap.tempLine); } catch(e){} gpsSnap.tempLine = null; }
                        }, 5000);
                    } catch(e) { /* ignore overlay errors */ }
                }

                if (!opts || !opts.suppressSuccess) {
                    showStatusBanner('GPS ile rotaya hizalandƒ±', 'success');
                }
            } catch (e) {
                console.error(e);
                showStatusBanner('Hizalama sƒ±rasƒ±nda hata', 'error');
            }
        }
        // ===== Advisory banners (Northbound only) =====
        function getKandilliThresholdAlong() {
            if (kandilliThresholdAlong != null) return kandilliThresholdAlong;
            // Use ƒ∞skele wp7 as Arnavutk√∂y vicinity
            const wp7 = ROUTES.iskele.coords[6];
            kandilliThresholdAlong = progressAlongReference(wp7[0], wp7[1]);
            return kandilliThresholdAlong;
        }

        function overtakesBeforeThresholdWithOwnSpeed(testSpeed) {
            const original = ownShip.speed;
            ownShip.speed = testSpeed;
            const evt = calculateEncounterEvent();
            ownShip.speed = original;
            if (!evt || evt.type !== 'overtake') return false;
            const thr = getKandilliThresholdAlong();
            return evt.along <= thr;
        }

        function updateAdvisoryBanners() {
            const container = document.getElementById('advisoryBanners');
            const distEl = document.getElementById('bannerDistance');
            const minEl = document.getElementById('bannerMinSpeed');

            if (!shipSimulationActive) { container.style.display = 'none'; return; }

            // Distance between ships (always shown during simulation)
            const ownPos = getShipPositionAtTime(ownShip, currentTime).position;
            const otherPos = getShipPositionAtTime(otherShip, currentTime).position;
            const nm = calculateDistance(ownPos[0], ownPos[1], otherPos[0], otherPos[1]);
            distEl.className = 'banner banner-distance';
            distEl.textContent = `ƒ∞ki gemi arasƒ± mesafe: ${nm.toFixed(2)} NM`;

            // Minimum speed banner (northbound scenario only)
            const bothNorth = ownShip.direction === 'northbound' && otherShip.direction === 'northbound';
            if (bothNorth) {
                // If either ship has reached/passed the Arnavutk√∂y (ƒ∞skele wp7) threshold, hide banner
                const thr = getKandilliThresholdAlong();
                const ownAlongNow = progressAlongReference(ownPos[0], ownPos[1]);
                const otherAlongNow = progressAlongReference(otherPos[0], otherPos[1]);
                if (ownAlongNow >= thr || otherAlongNow >= thr) {
                    minEl.style.display = 'none';
                } else {
                    // If own already ahead at t=0, hide min speed only
                    const own0 = getShipPositionAtTime(ownShip, 0);
                    const other0 = getShipPositionAtTime(otherShip, 0);
                    const a0 = progressAlongReference(own0.position[0], own0.position[1]);
                    const b0 = progressAlongReference(other0.position[0], other0.position[1]);
                    if (a0 < b0) {
                        let lo = 0.1, hi = 15.0, found = null;
                        for (let i = 0; i < 22; i++) {
                            const mid = (lo + hi) / 2;
                            if (overtakesBeforeThresholdWithOwnSpeed(mid)) { found = mid; hi = mid; }
                            else { lo = mid; }
                        }
                        let minText = '';
                        if (found == null) {
                            minText = 'Arnavutk√∂y Fenerinde yeti≈üme s√ºrati >15.0 kts.';
                        } else {
                            const roundedUp = Math.ceil(found * 10) / 10;
                            minText = `Arnavutk√∂y Fenerinde yeti≈üme s√ºrati ${roundedUp.toFixed(1)} kts.`;
                        }
                        minEl.style.display = '';
                        minEl.className = 'banner banner-minspeed info';
                        minEl.textContent = minText;
                    } else {
                        minEl.style.display = 'none';
                    }
                }
            } else {
                minEl.style.display = 'none';
            }

            container.style.display = 'flex';
        }
        
        
        
        
        // Update ship positions
        function updateShipPositions() {
            if (!shipSimulationActive) return;
            
            const ownPosData = getShipPositionAtTime(ownShip, currentTime);
            const otherPosData = getShipPositionAtTime(otherShip, currentTime);
            const ownPos = ownPosData.position;
            const otherPos = otherPosData.position;
            
            // Update ship markers
            if (ownShipMarker) {
                ownShipMarker.setLatLng(ownPos);
                const el = ownShipMarker.getElement();
                if (el && el.children && el.children[0]) {
                    el.children[0].style.transform = `rotate(${ownPosData.bearing}deg)`;
                }
            }
            if (otherShipMarker) {
                otherShipMarker.setLatLng(otherPos);
                const el2 = otherShipMarker.getElement();
                if (el2 && el2.children && el2.children[0]) {
                    el2.children[0].style.transform = `rotate(${otherPosData.bearing}deg)`;
                }
            }
            
            // Trails removed
            
            // Update time displays
            const timeDisplay = currentTime === 0 ? 'Now' : `+${currentTime} min`;
            document.getElementById('verticalTimeInfo').textContent = timeDisplay;
            
            
            
            // Update overtaking point (reference: Orta Kanal)
            updateDynamicMeetingPoint();
            // Also update banners dynamically on time slider changes
            updateAdvisoryBanners();
        }
        
        

        // Native Leaflet drag handlers (mobile-friendly)
        function attachNativeDrag(ship, marker) {
            marker.on('dragend', function() {
                // New initial conditions: reset overtaking/meeting marker
                resetDynamicMeetingPoint();
                const pos = marker.getLatLng();
                ship.customStartPosition = pos;
                ship.customStartTime = currentTime;
                updateShipPositions();
                updateDynamicMeetingPoint();
                updateAdvisoryBanners();
                // Disable auto GPS snap if user manually drags own ship
                if (ship.id === 'own' && gpsSnap && gpsSnap.enabled) {
                    stopGpsInterval();
                    gpsSnap.enabled = false;
                    updateGpsSnapUI();
                    showStatusBanner('Manuel konum ‚Äî GPS kapatƒ±ldƒ±', 'info');
                    // Also clear temporary GPS overlays immediately
                    try {
                        if (gpsSnap.tempMarker) { map.removeLayer(gpsSnap.tempMarker); gpsSnap.tempMarker = null; }
                        if (gpsSnap.tempLine) { map.removeLayer(gpsSnap.tempLine); gpsSnap.tempLine = null; }
                    } catch(e){}
                }
            });
        }

        // Start ship simulation
        function startShipSimulation() {
            shipSimulationActive = true;
            currentTime = 0;
            
            // Clear existing markers
            if (ownShipMarker) map.removeLayer(ownShipMarker);
            if (otherShipMarker) map.removeLayer(otherShipMarker);
            if (dynamicMeetingMarker) map.removeLayer(dynamicMeetingMarker);
            
            dynamicMeetingMarker = null;
            dynamicMeetingLocked = false;
            
            // Create ship markers
            const ownPosData = getShipPositionAtTime(ownShip, 0);
            const otherPosData = getShipPositionAtTime(otherShip, 0);
            const ownPos = ownPosData.position;
            const otherPos = otherPosData.position;
            
            const ownShipIcon = L.divIcon({
                className: 'ship-marker-custom',
                html: `<div class="ship-marker own-ship" style="transform: rotate(${ownPosData.bearing}deg);"></div>`,
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            });
            ownShipMarker = L.marker(ownPos, { icon: ownShipIcon, draggable: true }).addTo(map);

            const otherShipIcon = L.divIcon({
                className: 'ship-marker-custom',
                html: `<div class="ship-marker other-ship" style="transform: rotate(${otherPosData.bearing}deg);"></div>`,
                iconSize: [30, 30],
                iconAnchor: [15, 15]
            });
            otherShipMarker = L.marker(otherPos, { icon: otherShipIcon, draggable: true }).addTo(map);

            // Attach native drag handlers (mobile-friendly)
            attachNativeDrag(ownShip, ownShipMarker);
            attachNativeDrag(otherShip, otherShipMarker);
            
            // Trails are removed.
            
            // Show time slider
            document.getElementById('verticalTimeSlider').classList.add('active');
            
            // Update UI
            document.getElementById('shipToggle').classList.add('active');
            // Show GPS switch panel
            const gpsPanel = document.getElementById('gpsSnapPanel');
            if (gpsPanel) gpsPanel.style.display = 'flex';
            updateGpsSnapUI();
            
            // Reset slider
            document.getElementById('verticalTimeControl').value = 0;
            
            updateShipPositions();
            updateDynamicMeetingPoint();
            updateAdvisoryBanners();
        }
        
        // Stop ship simulation
        function stopShipSimulation() {
            shipSimulationActive = false;
            
            // Hide time slider
            document.getElementById('verticalTimeSlider').classList.remove('active');
            
            // Clear markers
            if (ownShipMarker) map.removeLayer(ownShipMarker);
            if (otherShipMarker) map.removeLayer(otherShipMarker);
            if (dynamicMeetingMarker) map.removeLayer(dynamicMeetingMarker);
            
            ownShipMarker = null;
            otherShipMarker = null;
            dynamicMeetingMarker = null;
            
            // Reset all ships custom positions
            ownShip.customStartPosition = null;
            ownShip.customStartTime = 0;
            otherShip.customStartPosition = null;
            otherShip.customStartTime = 0;
            
            // Reset time
            currentTime = 0;
            document.getElementById('verticalTimeControl').value = 0;
            
            // Update UI
            document.getElementById('shipToggle').classList.remove('active');
            // Hide GPS switch panel and stop watch
            const gpsPanel = document.getElementById('gpsSnapPanel');
            if (gpsPanel) gpsPanel.style.display = 'none';
            stopGpsInterval();
            gpsSnap.enabled = false;
            updateGpsSnapUI();

        }
        
        // Toggle ship simulation
        function toggleShipSimulation() {
            if (shipSimulationActive) {
                stopShipSimulation();
            } else {
                startShipSimulation();
            }
        }
        
        // Time slider event listener
        document.getElementById('verticalTimeControl').addEventListener('input', function(e) {
            if (shipSimulationActive) {
                currentTime = parseInt(e.target.value);
                updateShipPositions();
            }
        });
        
        // Ship speed controls
        document.getElementById('ownShipSpeed').addEventListener('input', function(e) {
            resetDynamicMeetingPoint();
            ownShip.speed = parseFloat(e.target.value);
            if (shipSimulationActive) {
                updateShipPositions();
            }
            updateAdvisoryBanners();
        });
        
        document.getElementById('otherShipSpeed').addEventListener('input', function(e) {
            resetDynamicMeetingPoint();
            otherShip.speed = parseFloat(e.target.value);
            if (shipSimulationActive) {
                updateShipPositions();
            }
            updateAdvisoryBanners();
        });

        // GPS switch events
        const gpsSwitch = document.getElementById('gpsSnapSwitch');
        if (gpsSwitch) {
            gpsSwitch.addEventListener('change', function(e) {
                setGpsSnapEnabled(!!e.target.checked);
            });
        }

        // Route selection controls
        const ownRouteSelect = document.getElementById('ownRouteSelect');
        const otherRouteSelect = document.getElementById('otherRouteSelect');
        // Initialize selects to ship defaults
        ownRouteSelect.value = ownShip.routeId;
        otherRouteSelect.value = otherShip.routeId;
        ownRouteSelect.addEventListener('change', function(e) {
            // Prevent selecting ƒ∞skele when southbound
            if (ownShip.direction === 'southbound' && e.target.value === 'iskele') {
                e.target.value = 'orta';
            }
            ownShip.routeId = e.target.value;
            if (shipSimulationActive) {
                startShipSimulation();
            }
            updateRoutesOverlay();
            updateAdvisoryBanners();
        });
        otherRouteSelect.addEventListener('change', function(e) {
            // Prevent selecting ƒ∞skele when southbound
            if (otherShip.direction === 'southbound' && e.target.value === 'iskele') {
                e.target.value = 'orta';
            }
            otherShip.routeId = e.target.value;
            if (shipSimulationActive) {
                startShipSimulation();
            }
            updateRoutesOverlay();
            updateAdvisoryBanners();
        });
        
        // Hamburger menu functions
        function toggleHamburgerMenu() {
            const dropdown = document.getElementById('hamburgerDropdown');
            const button = document.querySelector('.hamburger-button');
            
            if (dropdown.classList.contains('show')) {
                dropdown.classList.remove('show');
                button.innerHTML = '‚ò∞';
            } else {
                dropdown.classList.add('show');
                button.innerHTML = '√ó';
            }
        }
        
        function closeHamburgerMenu() {
            const dropdown = document.getElementById('hamburgerDropdown');
            const button = document.querySelector('.hamburger-button');
            dropdown.classList.remove('show');
            button.innerHTML = '‚ò∞';
        }

        // Close hamburger menu when clicking outside
        document.addEventListener('click', function(event) {
            const hamburgerMenu = document.querySelector('.mobile-hamburger-menu');
            if (!hamburgerMenu.contains(event.target)) {
                closeHamburgerMenu();
            }
        });

        // Route overlay helpers
        function clearRoutesOverlay() {
            // Remove lines
            Object.keys(routeOverlays.lines).forEach(id => {
                map.removeLayer(routeOverlays.lines[id]);
                delete routeOverlays.lines[id];
            });
            // Remove waypoints
            Object.keys(routeOverlays.waypoints).forEach(id => {
                const arr = routeOverlays.waypoints[id] || [];
                arr.forEach(m => map.removeLayer(m));
                delete routeOverlays.waypoints[id];
            });
        }

        function addRouteOverlay(routeId) {
            const route = ROUTES[routeId];
            if (!route) return;

            // Choose coords by current usage: if any ship uses this route southbound and SB coords exist, prefer those
            const useSB = ((ownShip.routeId === routeId && ownShip.direction === 'southbound') ||
                           (otherShip.routeId === routeId && otherShip.direction === 'southbound')) &&
                           Array.isArray(route.coordsSouthbound);
            const coordsToUse = useSB ? route.coordsSouthbound : route.coords;

            // Draw polyline (slim but visible)
            const style = getRouteStyle(routeId);
            const line = L.polyline(coordsToUse, { color: style.color, weight: style.weight, opacity: style.opacity });
            line.addTo(map);
            routeOverlays.lines[routeId] = line;

            // Add waypoints markers (compact numeric labels)
            const markers = [];
            coordsToUse.forEach((coord, idx) => {
                const num = String(idx + 1);
                const html = `<div class=\"route-waypoint\"><span class=\"route-wp-dot\" style=\"background:${style.color}\"></span><span class=\"route-wp-num\">${num}</span></div>`;
                const icon = L.divIcon({
                    className: 'route-waypoint',
                    html: html,
                    iconSize: [18, 12],
                    iconAnchor: [9, 6]
                });
                const m = L.marker(coord, { icon });
                m.addTo(map);
                markers.push(m);
            });
            routeOverlays.waypoints[routeId] = markers;
        }

        function updateRoutesOverlay() {
            if (!routesVisible) {
                clearRoutesOverlay();
                return;
            }

            const selected = new Set([ownShip.routeId, otherShip.routeId]);

            // Remove overlays for routes no longer selected
            Object.keys(routeOverlays.lines).forEach(id => {
                if (!selected.has(id)) {
                    map.removeLayer(routeOverlays.lines[id]);
                    delete routeOverlays.lines[id];
                }
            });
            Object.keys(routeOverlays.waypoints).forEach(id => {
                if (!selected.has(id)) {
                    (routeOverlays.waypoints[id] || []).forEach(m => map.removeLayer(m));
                    delete routeOverlays.waypoints[id];
                }
            });

            // Add overlays for newly selected routes
            selected.forEach(id => {
                if (!routeOverlays.lines[id]) {
                    addRouteOverlay(id);
                }
            });
        }

        // Other controls
        document.getElementById('mobileOpacitySlider').addEventListener('input', function(e) {
            const opacity = e.target.value / 100;
            if (openSeaMapLayer) {
                openSeaMapLayer.setOpacity(opacity);
            }
            document.getElementById('mobileOpacityValue').textContent = e.target.value;
        });
        
        function getRouteStyle(routeId){
            // Returns style based on dark mode
            if (darkModeEnabled) {
                const colorMap = { sancak: '#6b62a8', orta: '#c07b2e', iskele: '#8b5f5f' };
                return { color: colorMap[routeId] || '#8aa', weight: 2, opacity: 0.6 };
            }
            return { color: ROUTES[routeId].color, weight: 3, opacity: 0.85 };
        }

        function applyDarkModeTheme(){
            // Toggle class on body
            if (darkModeEnabled) document.body.classList.add('dark-mode');
            else document.body.classList.remove('dark-mode');

            // Restyle existing route overlays
            Object.keys(routeOverlays.lines).forEach(id => {
                const s = getRouteStyle(id);
                try { routeOverlays.lines[id].setStyle({ color: s.color, weight: s.weight, opacity: s.opacity }); } catch {}
            });

            // Rebuild waypoint markers to update dot colors
            if (routesVisible) {
                const selected = new Set([ownShip.routeId, otherShip.routeId]);
                // Clear then re-add
                clearRoutesOverlay();
                selected.forEach(id => addRouteOverlay(id));
            }

            // Redraw TSS overlay with subdued styling in dark mode
            try { createManualTSS(); } catch {}

            // Switch base map to dark/light tiles
            try {
                const url = darkModeEnabled ? BASEMAPS.dark : BASEMAPS.light;
                if (baseLayer) { map.removeLayer(baseLayer); }
                baseLayer = L.tileLayer(url, { attribution: '¬© OpenStreetMap contributors, ¬© CartoDB', maxZoom: MAX_ZOOM });
                baseLayer.addTo(map);
            } catch {}

            // Tweak OpenSeaMap opacity to reduce brightness in dark mode
            try { if (openSeaMapLayer) openSeaMapLayer.setOpacity(darkModeEnabled ? 0.18 : 0.3); } catch {}
        }

        document.getElementById('mobileDarkModeToggle').addEventListener('change', function(e) {
            darkModeEnabled = e.target.checked;
            applyDarkModeTheme();
        });

        // Routes visibility toggle
        document.getElementById('mobileRoutesToggle').addEventListener('change', function(e) {
            routesVisible = e.target.checked;
            updateRoutesOverlay();
        });

        document.getElementById('mobileCurrentAdvantageToggle').addEventListener('change', function(e) {
            currentAdvantageEnabled = e.target.checked;
            const display = document.getElementById('mobileCurrentAdvantageDisplay');
            if (currentAdvantageEnabled) {
                display.textContent = 'Akƒ±ntƒ± etkisi aktif';
            } else {
                display.textContent = 'Akƒ±ntƒ± etkisi deaktif';
            }
            // Recalculate positions when advantage is toggled
            if (shipSimulationActive) {
                updateShipPositions();
                updateDynamicMeetingPoint();
                updateAdvisoryBanners();
            }
        });
        
        // Initialize
        // Initialize routes overlay (hidden by default)
        updateRoutesOverlay();
        // Initialize advisory banners
        updateAdvisoryBanners();

    </script>
    <!-- Variant v3: Mini HUD for akƒ±ntƒ± etkisi -->
    <style>
      .mini-hud { position: fixed; right: 10px; bottom: 10px; z-index: 5000; background: rgba(0,0,0,0.55); color: #fff; font-family: 'Courier New', monospace; font-size: 12px; padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.25); min-width: 200px; }
      .mini-hud .rem { font-size: 11px; opacity: 0.8; margin-top: 4px; }
    </style>
    <script>
      window.addEventListener('load', function(){
      (function(){
        const EFFECT_THRESHOLD = 0.3;
        let hud=null, ownEl=null, othEl=null, remEl=null; let lastReminderKey=null;
        // Glow overlays (like v4 but without labels)
        let glowOwnLine=null, glowOthLine=null;
        function ensure(){ if(!hud){ hud=document.createElement('div'); hud.className='mini-hud'; ownEl=document.createElement('div'); othEl=document.createElement('div'); remEl=document.createElement('div'); remEl.className='rem'; remEl.style.display='none'; hud.appendChild(ownEl); hud.appendChild(othEl); hud.appendChild(remEl); document.body.appendChild(hud);} }
        function routeDisplayName(id){ return id==='orta'?'Orta Kanal': id==='sancak'?'Sancak Hat':'ƒ∞skele Hat'; }
        function wpRangeLabel(ship, segIndex){
          const id=ship.routeId, dir=ship.direction;
          if(id==='iskele'&&dir==='northbound'){
            if(segIndex===4) return 'wp5‚Äìwp6';
            if(segIndex===5) return 'wp6‚Äìwp7';
            if(segIndex===6||segIndex===7) return 'wp7‚Äìwp9';
            if(segIndex===10) return 'wp11‚Äìwp12';
            if(segIndex===12||segIndex===13) return 'wp13‚Äìwp15';
          }
          if(id==='sancak'&&dir==='southbound'){
            if(segIndex===6)return'wp7‚Äìwp8';
            if(segIndex===11)return'wp12‚Äìwp13';
            if(segIndex===12||segIndex===13)return'wp13‚Äìwp15';
          }
          if(id==='orta'&&dir==='southbound'){
            if(segIndex===11)return'wp12‚Äìwp13';
            if(segIndex===12)return'wp13‚Äìwp14';
          }
          return `wp${segIndex+1}‚Äìwp${segIndex+2}`;
        }
        // HUD message builder (show revised speed)
        function buildMsgSpeed(ship, seg, effKts){ return `${routeDisplayName(ship.routeId)} ${wpRangeLabel(ship,seg)}: gemi s√ºrati ${effKts.toFixed(1)} kts`; }
        function contextKey(){ try{ return `${ownShip.routeId}:${ownShip.direction}|${otherShip.routeId}:${otherShip.direction}|${currentAdvantageEnabled?1:0}`;}catch{return'na';}}
        
        function setGlow(lineRef, wps, seg, delta){
          // In dark mode, avoid bright glow overlays to protect night vision
          if (typeof darkModeEnabled !== 'undefined' && darkModeEnabled) {
            if (lineRef) { try { map.removeLayer(lineRef); } catch {} }
            return null;
          }
          const a=wps[seg], b=wps[seg+1]; if(!a||!b) return lineRef;
          const color = delta>=0 ? 'rgba(76,175,80,0.65)' : 'rgba(198,40,40,0.65)';
          const opts = { color, weight: 6, opacity: 0.8 };
          if(!lineRef){ lineRef = L.polyline([a,b], opts).addTo(map); }
          else { lineRef.setStyle(opts); lineRef.setLatLngs([a,b]); if(!map.hasLayer(lineRef)) lineRef.addTo(map); }
          return lineRef;
        }
        function clearGlow(){ if(glowOwnLine) try{ map.removeLayer(glowOwnLine);}catch{}; if(glowOthLine) try{ map.removeLayer(glowOthLine);}catch{}; glowOwnLine=glowOthLine=null; }
        function poll(){ if (typeof shipSimulationActive === 'undefined') { return; } if(!shipSimulationActive){ if(hud) hud.style.display='none'; clearGlow(); return; } ensure(); hud.style.display='block'; try { const own=getShipPositionAtTime(ownShip,currentTime), oth=getShipPositionAtTime(otherShip,currentTime); const os=own.segmentIndex, ts=oth.segmentIndex;
          const owps = ownShip.getStartingWaypoints();
          const odists = getSegmentDistances(owps);
          const twps = otherShip.getStartingWaypoints();
          const tdists = getSegmentDistances(twps);
          const oOffset = typeof own.offsetInSegmentNm === 'number' ? own.offsetInSegmentNm : 0;
          const tOffset = typeof oth.offsetInSegmentNm === 'number' ? oth.offsetInSegmentNm : 0;
          const oEff = getEffectiveSpeedWithTurn(ownShip, os, oOffset, owps, odists);
          const tEff = getEffectiveSpeedWithTurn(otherShip, ts, tOffset, twps, tdists);
          const od = oEff - ownShip.speed;
          const td = tEff - otherShip.speed;
          // Update glow overlays
          clearGlow();
          if (Math.abs(od) >= EFFECT_THRESHOLD) glowOwnLine = setGlow(glowOwnLine, owps, os, od);
          if (Math.abs(td) >= EFFECT_THRESHOLD) glowOthLine = setGlow(glowOthLine, twps, ts, td);
          // HUD shows revised speeds always
          ownEl.textContent = buildMsgSpeed(ownShip, os, oEff);
          othEl.textContent = buildMsgSpeed(otherShip, ts, tEff);
          const bothLow=Math.abs(od)<EFFECT_THRESHOLD && Math.abs(td)<EFFECT_THRESHOLD; const ctx=contextKey(); if(bothLow && ctx!==lastReminderKey){ remEl.textContent='Akƒ±ntƒ± yoksa akƒ±ntƒ± etkisi √∂zelliƒüini kapatabilirsiniz.'; remEl.style.display='block'; setTimeout(()=>{ remEl.style.display='none'; }, 4000); lastReminderKey=ctx; }
        } catch(e){} }
        setInterval(poll, 400);
        // Reset reminder context on key UI changes so it can show again when relevant
        ['mobileCurrentAdvantageToggle','ownRouteSelect','otherRouteSelect','ownNorthbound','ownSouthbound','otherNorthbound','otherSouthbound'].forEach(id=>{
          const el = document.getElementById(id);
          if (el) {
            const evt = (id.includes('Select')||id.includes('Toggle')) ? 'change' : 'click';
            el.addEventListener(evt, ()=>{ lastReminderKey = null; });
          }
        });
      })();
      });
    </script>
</body>
</html>
